{"remainingRequest":"/home/vishwvir/company_projects/tata/web/ui_propensity/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js??ref--8-1!/home/vishwvir/company_projects/tata/web/ui_propensity/node_modules/chartjs-plugin-piechart-outlabels/dist/chartjs-plugin-piechart-outlabels.js","dependencies":[{"path":"/home/vishwvir/company_projects/tata/web/ui_propensity/node_modules/chartjs-plugin-piechart-outlabels/dist/chartjs-plugin-piechart-outlabels.js","mtime":1596454950000},{"path":"/home/vishwvir/company_projects/tata/web/ui_propensity/node_modules/cache-loader/dist/cjs.js","mtime":1596454942000},{"path":"/home/vishwvir/company_projects/tata/web/ui_propensity/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js","mtime":1596454940000}],"contextDependencies":[],"result":["/*!\n * chartjs-plugin-piechart-outlabels\n * http://chartjs.org/\n * Version: 0.1.4\n *\n * Copyright 2018 Neckster\n * Released under the MIT license\n * https://github.com/Neckster/chartjs-plugin-piechart-outlabels/blob/master/LICENSE\n */\n(function (global, factory) {\n\ttypeof exports === 'object' && typeof module !== 'undefined' ? factory(require('chart.js')) :\n\ttypeof define === 'function' && define.amd ? define(['chart.js'], factory) :\n\t(factory(global.Chart));\n}(this, (function (Chart$1) { 'use strict';\n\nChart$1 = Chart$1 && Chart$1.hasOwnProperty('default') ? Chart$1['default'] : Chart$1;\n\n'use strict';\r\n\r\nvar helpers = Chart$1.helpers;\r\n\r\nvar helpers$1 = helpers.merge(helpers, {\r\n\t// @todo move this method in Chart.helpers.canvas.toFont (deprecates helpers.fontString)\r\n\t// @see https://developer.mozilla.org/en-US/docs/Web/CSS/font\r\n\ttoFontString: function(font) {\r\n\t\tif (!font || helpers.isNullOrUndef(font.size) || helpers.isNullOrUndef(font.family)) {\r\n\t\t\treturn null;\r\n\t\t}\r\n\r\n\t\treturn (font.style ? font.style + ' ' : '')\r\n\t\t\t+ (font.weight ? font.weight + ' ' : '')\r\n\t\t\t+ font.size + 'px '\r\n\t\t\t+ font.family;\r\n\t},\r\n\r\n\t// @todo move this in Chart.helpers.canvas.textSize\r\n\t// @todo cache calls of measureText if font doesn't change?!\r\n\ttextSize: function(ctx, lines, font) {\r\n\t\tvar items = [].concat(lines);\r\n\t\tvar ilen = items.length;\r\n\t\tvar prev = ctx.font;\r\n\t\tvar width = 0;\r\n\t\tvar i;\r\n\r\n\t\tctx.font = font.string;\r\n\r\n\t\tfor (i = 0; i < ilen; ++i) {\r\n\t\t\twidth = Math.max(ctx.measureText(items[i]).width, width);\r\n\t\t}\r\n\r\n\t\tctx.font = prev;\r\n\r\n\t\treturn {\r\n\t\t\theight: ilen * font.lineHeight,\r\n\t\t\twidth: width\r\n\t\t};\r\n\t},\r\n\r\n\t// @todo move this method in Chart.helpers.options.toFont\r\n\tparseFont: function(value, height) {\r\n\t\t\r\n\t\tvar global = Chart$1.defaults.global;\r\n\t\tvar size = helpers.valueOrDefault(value.size, global.defaultFontSize);\r\n\r\n\t\t\r\n\t\tif (value.resizable) {\r\n\t\t\tsize = this.adaptTextSizeToHeight(height, value.minSize, value.maxSize);\r\n\t\t}\r\n\r\n\t\tvar font = {\r\n\t\t\tfamily: helpers.valueOrDefault(value.family, global.defaultFontFamily),\r\n\t\t\tlineHeight: helpers.options.toLineHeight(value.lineHeight, size),\r\n\t\t\tsize: size,\r\n\t\t\tstyle: helpers.valueOrDefault(value.style, global.defaultFontStyle),\r\n\t\t\tweight: helpers.valueOrDefault(value.weight, null),\r\n\t\t\tstring: ''\r\n\t\t};\r\n\r\n\t\tfont.string = helpers.toFontString(font);\r\n\t\treturn font;\r\n\t},\r\n\r\n\tadaptTextSizeToHeight: function(height, min, max) {\r\n\t\tvar size = (height / 100) * 2.5;\r\n\t\tif(min && size < min) {\r\n\t\t\treturn min;\r\n\t\t}\r\n\t\tif(max && size > max) {\r\n\t\t\treturn max;\r\n\t\t}\r\n\t\treturn size;\r\n\t}\r\n});\n\n/**\r\n * @module Options\r\n */\r\n\r\n'use strict';\r\n\r\nvar defaults = {\r\n\r\n\tLABEL_KEY: '$outlabels',\r\n\r\n\t/**\r\n\t * The color used to draw the background of the label rect.\r\n\t * @member {String|Array|Function|null}\r\n\t * @default null (adaptive background)\r\n\t */\r\n\tbackgroundColor: function(context) {\r\n\t\treturn context.dataset.backgroundColor;\r\n\t},\r\n\r\n\t/**\r\n\t * The color used to draw the border of the label rect.\r\n\t * @member {String|Array|Function|null}\r\n\t * @default null (adaptive border color)\r\n\t */\r\n\tborderColor: function(context) {\r\n\t\treturn context.dataset.backgroundColor;\r\n\t},\r\n\r\n\t/**\r\n\t * The color used to draw the line between label and arc of the chart.\r\n\t * @member {String|Array|Function|null}\r\n\t * @default null (adaptive line color)\r\n\t */\r\n\tlineColor: function(context) {\r\n\t\treturn context.dataset.backgroundColor;\r\n\t},\r\n\r\n\t/**\r\n\t * The border radius used to add rounded corners to the label rect.\r\n\t * @member {Number|Array|Function}\r\n\t * @default 0 (not rounded)\r\n\t */\r\n\tborderRadius: 0,\r\n\r\n\t/**\r\n\t * The border width of the surrounding frame.\r\n\t * @member {Number|Array|Function}\r\n\t * @default 0 (no border)\r\n\t */\r\n\tborderWidth: 0,\r\n\r\n\t/**\r\n\t * The width (thickness) of the line between label and chart arc.\r\n\t * @member {Number|Array|Function}\r\n\t * @default 2 \r\n\t */\r\n\tlineWidth: 2,\r\n\r\n\t/**\r\n\t * The color used to draw the label text.\r\n\t * @member {String|Array|Function}\r\n\t * @default white\r\n\t */\r\n\tcolor: 'white',\r\n\r\n\t/**\r\n\t * Whether to display labels global (boolean) or per data (function)\r\n\t * @member {Boolean|Array|Function}\r\n\t * @default true\r\n\t */\r\n\tdisplay: true,\r\n\r\n\t/**\r\n\t * The font options used to draw the label text.\r\n\t * @member {Object|Array|Function}\r\n\t * @prop {Boolean} font.family - defaults to Chart.defaults.global.defaultFontFamily\r\n\t * @prop {Boolean} font.size - defaults to Chart.defaults.global.defaultFontSize\r\n\t * @prop {Boolean} font.style - defaults to Chart.defaults.global.defaultFontStyle\r\n\t * @prop {Boolean} font.weight - defaults to 'normal'\r\n\t * @prop {Boolean} font.maxSize - defaults to undefined (unlimited)\r\n\t * @prop {Boolean} font.minSize - defaults to undefined (unlimited)\r\n\t * @prop {Boolean} font.resizable - defaults to true\r\n\t * @default Chart.defaults.global.defaultFont.*\r\n\t */\r\n\tfont: {\r\n\t\tfamily: undefined,\r\n\t\tsize: undefined,\r\n\t\tstyle: undefined,\r\n\t\tweight: null,\r\n\t\tmaxSize: null,\r\n\t\tminSize: null,\r\n\t\tresizable: true,\r\n\t},\r\n\r\n\t/**\r\n\t * The line height (in pixel) to use for multi-lines labels.\r\n\t * @member {Number|Array|Function|undefined}\r\n\t * @default 1.2\r\n\t */\r\n\tlineHeight: 1.2,\r\n\r\n\r\n\t/**\r\n\t * The padding (in pixels) to apply between the text and the surrounding frame.\r\n\t * @member {Number|Object|Array|Function}\r\n\t * @prop {Number} padding.top - Space above the text.\r\n\t * @prop {Number} padding.right - Space on the right of the text.\r\n\t * @prop {Number} padding.bottom - Space below the text.\r\n\t * @prop {Number} padding.left - Space on the left of the text.\r\n\t * @default 4 (all values)\r\n\t */\r\n\tpadding: {\r\n\t\ttop: 4,\r\n\t\tright: 4,\r\n\t\tbottom: 4,\r\n\t\tleft: 4\r\n\t},\r\n\r\n\t/**\r\n\t * Text alignment for multi-lines labels ('left'|'right'|'start'|'center'|'end').\r\n\t * @member {String|Array|Function}\r\n\t * @default 'center'\r\n\t */\r\n\ttextAlign: 'center',\r\n\r\n\t/**\r\n\t * The length of the line between label and chart arc.\r\n\t * @member {Number|Array|Function|undefined}\r\n\t * @default 40\r\n\t */\r\n\tstretch: 40,\r\n\r\n\t/**\r\n\t * The text of the label.\r\n\t * @member {String}\r\n\t * @default '%l %p' (label name and value percentage)\r\n\t */\r\n\ttext: '%l %p',\r\n\r\n\t/**\r\n\t * The level of zoom (out) for pie/doughnut chart in percent.\r\n\t * @member {Number}\r\n\t * @default 50 (%)\r\n\t */\r\n\tzoomOutPercentage: 50,\r\n\r\n\t/**\r\n\t * The count of numbers after the point separator for float values of percent property\r\n\t * @member {Number}\r\n\t * @default 1\r\n\t */\r\n\tpercentPrecision: 1,\r\n\t\r\n\t/**\r\n\t * The count of numbers after the point separator for float values of value property\r\n\t * @member {Number}\r\n\t * @default 3\r\n\t */\r\n\tvaluePrecision: 3\r\n};\n\n'use strict';\r\n\r\nvar outlabeledCharts = {\r\n\tinit: function() {\r\n\t\t/* HOTFIX: fix trunc function for IE-11 */\r\n\t\tif (!Math.trunc) {\r\n\t\t\tMath.trunc = function(v) {\r\n\t\t\t\tv = +v;\r\n\t\t\t\treturn (v - v % 1)   ||   (!isFinite(v) || v === 0 ? v : v < 0 ? -0 : 0);\r\n\t\t\t};\r\n\t\t}\r\n\r\n\t\tChart.defaults.outlabeledDoughnut = Chart.defaults.doughnut;\r\n\t\tChart.defaults.outlabeledPie = Chart.defaults.pie;\r\n\r\n\t\tvar customUpdate = function(reset) {\r\n\t\t\tChart.controllers.doughnut.prototype.update.call(this);\r\n\t\t\tvar me = this;\r\n\t\t\tvar meta = me.getMeta();\r\n\t\t\tvar zoomOutPercentage = me.chart.options.zoomOutPercentage || defaults.zoomOutPercentage;\r\n\r\n\t\t\tme.outerRadius *= 1 - zoomOutPercentage / 100;\r\n\t\t\tme.innerRadius *= 1 - zoomOutPercentage / 100;\r\n\r\n\t\t\tChart.helpers.each(meta.data, function(arc, index) {\r\n\t\t\t\tme.updateElement(arc, index, reset);\r\n\t\t\t});\r\n\t\t};\r\n\r\n\t\tvar customDoughnut = Chart.controllers.doughnut.extend({\r\n\t\t\tupdate: customUpdate\r\n\t\t});\r\n\r\n\t\tvar customPie = Chart.controllers.pie.extend({\r\n\t\t\tupdate: customUpdate\r\n\t\t});\r\n\r\n\t\tChart.controllers.outlabeledPie = customPie;\r\n\t\tChart.controllers.outlabeledDoughnut = customDoughnut;\r\n\t}\r\n};\n\n'use strict';\r\n\r\nvar positioners = {\r\n\tcenter: function(arc, stretch) {\r\n\t\tvar angle = (arc.startAngle + arc.endAngle) / 2;\r\n\t\tvar cosA = Math.cos(angle);\r\n\t\tvar sinA = Math.sin(angle);\r\n\t\tvar d = arc.outerRadius;\r\n\r\n\t\tvar stretchedD = d + stretch;\r\n\t\treturn {\r\n\t\t\tx: arc.x + cosA * stretchedD,\r\n\t\t\ty: arc.y + sinA * stretchedD,\r\n\t\t\td: stretchedD,\r\n\t\t\tarc: arc,\r\n\t\t\tanchor: {\r\n\t\t\t\tx: arc.x + cosA * d,\r\n\t\t\t\ty: arc.y + sinA * d,\r\n\t\t\t},\r\n\t\t\tcopy: {\r\n\t\t\t\tx: arc.x + cosA * stretchedD,\r\n\t\t\t\ty: arc.y + sinA * stretchedD\r\n\t\t\t}\r\n\t\t};\r\n\t},\r\n\r\n\tmoveFromAnchor: function(center, dist) {\r\n\t\tvar arc = center.arc;\r\n\t\tvar d = center.d;\r\n\t\tvar angle = (arc.startAngle + arc.endAngle) / 2;\r\n\t\tvar cosA = Math.cos(angle);\r\n\t\tvar sinA = Math.sin(angle);\r\n\r\n\t\td += dist;\r\n\r\n\t\treturn {\r\n\t\t\tx: arc.x + cosA * d,\r\n\t\t\ty: arc.y + sinA * d,\r\n\t\t\td: d,\r\n\t\t\tarc: arc,\r\n\t\t\tanchor: center.anchor,\r\n\t\t\tcopy: {\r\n\t\t\t\tx: arc.x + cosA * d,\r\n\t\t\t\ty: arc.y + sinA * d\r\n\t\t\t}\r\n\t\t};\r\n\t}\r\n};\n\n'use strict';\r\n\r\nvar helpers$2 = Chart$1.helpers;\r\nvar LABEL_KEY$1 = defaults.LABEL_KEY;\r\n\r\nvar classes = {\r\n\tOutLabel: function(el, index, ctx, config, context) {\r\n\t\tvar resolve = Chart$1.helpers.options.resolve;\r\n\t\t// Check whether the label should be displayed\r\n\t\tif (!resolve([config.display, true], context, index)) {\r\n\t\t\tthrow new Error('Label display property is set to false.');\r\n\t\t}\r\n\t\t// Init text\r\n\t\tvar value = context.dataset.data[index];\r\n\t\tvar label = context.labels[index];\r\n\t\tvar text = resolve([config.text, defaults.text], context, index);\r\n\r\n\t\t/* Replace label marker */\r\n\t\ttext = text.replace(/%l/gi, label);\r\n\r\n\t\t/* Replace value marker with possible precision value */\r\n\t\t(text.match(/%v\\.?(\\d*)/gi) || []).map(function(val) {\r\n\t\t\tvar prec = val.replace(/%v\\./gi, '');\r\n\t\t\tif (prec.length) {\r\n\t\t\t\treturn +prec;\r\n\t\t\t} else {\r\n\t\t\t\treturn config.valuePrecision || defaults.valuePrecision;\r\n\t\t\t}\r\n\t\t}).forEach(function(val) {\r\n\t\t\ttext = text.replace(/%v\\.?(\\d*)/i, value.toFixed(val));\r\n\t\t});\r\n\r\n\t\t/* Replace percent marker with possible precision value */\r\n\t\t(text.match(/%p\\.?(\\d*)/gi) || []).map(function(val) {\r\n\t\t\tvar prec = val.replace(/%p\\./gi, '');\r\n\t\t\tif (prec.length) {\r\n\t\t\t\treturn +prec;\r\n\t\t\t} else  {\r\n\t\t\t\treturn config.percentPrecision || defaults.percentPrecision;\r\n\t\t\t}\r\n\t\t}).forEach(function(val) {\r\n\t\t\ttext = text.replace(/%p\\.?(\\d*)/i, (context.percent * 100).toFixed(val) + '%');\r\n\t\t});\r\n\r\n\t\t// Count lines\r\n\t\tvar lines = text.match(/[^\\r\\n]+/g);\r\n\r\n\t\t// If no lines => nothng to display\r\n\t\tif (!lines || !lines.length) {\r\n\t\t\tthrow new Error('No text to show.');\r\n\t\t}\r\n\r\n\t\t// Remove unnecessary spaces\r\n\t\tfor (var i = 0; i < lines.length; ++i) {\r\n\t\t\tlines[i] = lines[i].trim();\r\n\t\t}\r\n\r\n\t\t/* ===================== CONSTRUCTOR ==================== */\r\n\t\tthis.init = function(text, lines) {\r\n\t\t\t// If everything ok -> begin initializing\r\n\t\t\tthis.encodedText = config.text;\r\n\t\t\tthis.text = text;\r\n\t\t\tthis.lines = lines;\r\n\t\t\tthis.label = label;\r\n\t\t\tthis.value = value;\r\n\t\t\tthis.ctx = ctx;\r\n\r\n\t\t\t// Init style\r\n\t\t\tthis.style = {\r\n\t\t\t\tbackgroundColor: resolve([config.backgroundColor, defaults.backgroundColor, 'black'], context, index),\r\n\t\t\t\tborderColor: resolve([config.borderColor, defaults.borderColor, 'black'], context, index),\r\n\t\t\t\tborderRadius: resolve([config.borderRadius, 0], context, index),\r\n\t\t\t\tborderWidth: resolve([config.borderWidth, 0], context, index),\r\n\t\t\t\tlineWidth: resolve([config.lineWidth, 2], context, index),\r\n\t\t\t\tlineColor: resolve([config.lineColor, defaults.lineColor, 'black'], context, index),\r\n\t\t\t\tcolor: resolve([config.color, 'white'], context, index),\r\n\t\t\t\tfont: helpers$2.parseFont(resolve([config.font, {resizable: true}]), ctx.canvas.style.height.slice(0, -2)),\r\n\t\t\t\tpadding: helpers$2.options.toPadding(resolve([config.padding, 0], context, index)),\r\n\t\t\t\ttextAlign: resolve([config.textAlign, 'left'], context, index),\r\n\t\t\t};\r\n\r\n\t\t\tthis.stretch = resolve([config.stretch, 40], context, index);\r\n\t\t\tthis.size = helpers$2.textSize(ctx, this.lines, this.style.font);\r\n\r\n\t\t\tthis.offsetStep = this.size.width / 20;\r\n\t\t\tthis.offset = {\r\n\t\t\t\tx: 0,\r\n\t\t\t\ty: 0\r\n\t\t\t};\r\n\t\t\tthis.predictedOffset = this.offset;\r\n\r\n\t\t\tvar angle = -((el._model.startAngle + el._model.endAngle) / 2) / (Math.PI);\r\n\t\t\tvar val = Math.abs(angle - Math.trunc(angle));\r\n\r\n\t\t\tif (val > 0.45 && val < 0.55) {\r\n\t\t\t\tthis.predictedOffset.x = 0;\r\n\t\t\t} else if (angle <= 0.45 && angle >= -0.45) {\r\n\t\t\t\tthis.predictedOffset.x = this.size.width / 2;\r\n\t\t\t} else if (angle >= -1.45 && angle <= -0.55) {\r\n\t\t\t\tthis.predictedOffset.x = -this.size.width / 2;\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\tthis.init(text, lines);\r\n\r\n\t\t/* COMPUTING RECTS PART */\r\n\t\tthis.computeLabelRect = function() {\r\n\t\t\tvar width = this.textRect.width + 2 * this.style.borderWidth;\r\n\t\t\tvar height = this.textRect.height + 2 * this.style.borderWidth;\r\n\r\n\t\t\tvar x = this.textRect.x - this.style.padding.left - this.style.borderWidth;\r\n\t\t\tvar y = this.textRect.y - this.style.padding.top - this.style.borderWidth;\r\n\r\n\t\t\twidth += this.style.padding.width;\r\n\t\t\theight += this.style.padding.height;\r\n\r\n\t\t\treturn {\r\n\t\t\t\tx: x,\r\n\t\t\t\ty: y,\r\n\t\t\t\twidth: width,\r\n\t\t\t\theight: height\r\n\t\t\t};\r\n\t\t};\r\n\r\n\t\tthis.computeTextRect = function() {\r\n\t\t\treturn {\r\n\t\t\t\tx: this.center.x - (this.size.width / 2),\r\n\t\t\t\ty: this.center.y - (this.size.height / 2),\r\n\t\t\t\twidth: this.size.width,\r\n\t\t\t\theight: this.size.height\r\n\t\t\t};\r\n\t\t};\r\n\r\n\t\tthis.getPoints = function() {\r\n\t\t\treturn [\r\n\t\t\t\t{\r\n\t\t\t\t\tx: this.labelRect.x,\r\n\t\t\t\t\ty: this.labelRect.y\r\n\t\t\t\t},\r\n\t\t\t\t{\r\n\t\t\t\t\tx: this.labelRect.x + this.labelRect.width,\r\n\t\t\t\t\ty: this.labelRect.y\r\n\t\t\t\t},\r\n\t\t\t\t{\r\n\t\t\t\t\tx: this.labelRect.x + this.labelRect.width,\r\n\t\t\t\t\ty: this.labelRect.y + this.labelRect.height\r\n\t\t\t\t},\r\n\t\t\t\t{\r\n\t\t\t\t\tx: this.labelRect.x,\r\n\t\t\t\t\ty: this.labelRect.y + this.labelRect.height\r\n\t\t\t\t}\r\n\t\t\t];\r\n\t\t};\r\n\r\n\t\tthis.containsPoint = function(point, offset) {\r\n\t\t\tif (!offset) {\r\n\t\t\t\toffset = 5;\r\n\t\t\t}\r\n\r\n\t\t\treturn\tthis.labelRect.x - offset <= point.x && point.x <= this.labelRect.x + this.labelRect.width + offset\r\n\t\t\t\t\t\t\t&&\r\n\t\t\t\t\t\tthis.labelRect.y - offset <= point.y && point.y <= this.labelRect.y + this.labelRect.height + offset;\r\n\t\t};\r\n\r\n\r\n\t\t/* ======================= DRAWING ======================= */\r\n\t\t// Draw label text\r\n\t\tthis.drawText = function() {\r\n\t\t\tvar align = this.style.textAlign;\r\n\t\t\tvar font = this.style.font;\r\n\t\t\tvar lh = font.lineHeight;\r\n\t\t\tvar color = this.style.color;\r\n\t\t\tvar ilen = this.lines.length;\r\n\t\t\tvar x, y, idx;\r\n\r\n\t\t\tif (!ilen || !color) {\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tx = this.textRect.x;\r\n\t\t\ty = this.textRect.y + lh / 2;\r\n\r\n\t\t\tif (align === 'center') {\r\n\t\t\t\tx += this.textRect.width / 2;\r\n\t\t\t} else if (align === 'end' || align === 'right') {\r\n\t\t\t\tx += this.textRect.width;\r\n\t\t\t}\r\n\r\n\t\t\tthis.ctx.font = this.style.font.string;\r\n\t\t\tthis.ctx.fillStyle = color;\r\n\t\t\tthis.ctx.textAlign = align;\r\n\t\t\tthis.ctx.textBaseline = 'middle';\r\n\r\n\t\t\tfor (idx = 0; idx < ilen; ++idx) {\r\n\t\t\t\tthis.ctx.fillText(\r\n\t\t\t\t\tthis.lines[idx],\r\n\t\t\t\t\tMath.round(x),\r\n\t\t\t\t\tMath.round(y),\r\n\t\t\t\t\tMath.round(this.textRect.width)\r\n\t\t\t\t);\r\n\r\n\t\t\t\ty += lh;\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\t// Draw label box\r\n\t\tthis.drawLabel = function() {\r\n\t\t\tctx.beginPath();\r\n\t\t\thelpers$2.canvas.roundedRect(\r\n\t\t\t\tthis.ctx,\r\n\t\t\t\tMath.round(this.labelRect.x),\r\n\t\t\t\tMath.round(this.labelRect.y),\r\n\t\t\t\tMath.round(this.labelRect.width),\r\n\t\t\t\tMath.round(this.labelRect.height),\r\n\t\t\t\tthis.style.borderRadius\r\n\t\t\t);\r\n\t\t\tthis.ctx.closePath();\r\n\r\n\t\t\tif (this.style.backgroundColor) {\r\n\t\t\t\tthis.ctx.fillStyle = this.style.backgroundColor || 'black';\r\n\t\t\t\tthis.ctx.fill();\r\n\t\t\t}\r\n\r\n\t\t\tif (this.style.borderColor && this.style.borderWidth) {\r\n\t\t\t\tthis.ctx.strokeStyle = this.style.borderColor;\r\n\t\t\t\tthis.ctx.lineWidth = this.style.borderWidth;\r\n\t\t\t\tthis.ctx.lineJoin = 'miter';\r\n\t\t\t\tthis.ctx.stroke();\r\n\t\t\t}\r\n\t\t};\r\n\r\n\r\n\t\tthis.drawLine = function() {\r\n\t\t\tthis.ctx.save();\r\n\r\n\t\t\tthis.ctx.strokeStyle = this.style.lineColor;\r\n\t\t\tthis.ctx.lineWidth = this.style.lineWidth;\r\n\t\t\tthis.ctx.lineJoin = 'miter';\r\n\t\t\tthis.ctx.beginPath();\r\n\t\t\tthis.ctx.moveTo(this.center.anchor.x, this.center.anchor.y);\r\n\t\t\tthis.ctx.lineTo(this.center.copy.x, this.center.copy.y);\r\n\t\t\tthis.ctx.stroke();\r\n\r\n\t\t\tthis.ctx.restore();\r\n\t\t};\r\n\r\n\t\tthis.draw = function() {\r\n\t\t\tthis.drawLabel();\r\n\t\t\tthis.drawText();\r\n\t\t};\r\n\r\n\r\n\t\tthis.update = function(view, elements, max) {\r\n\t\t\tthis.center = positioners.center(view, this.stretch);\r\n\t\t\tthis.moveLabelToOffset();\r\n\r\n\t\t\tthis.center.x += this.offset.x;\r\n\t\t\tthis.center.y += this.offset.y;\r\n\r\n\t\t\tvar valid = false;\r\n\r\n\t\t\twhile (!valid) {\r\n\t\t\t\tthis.textRect = this.computeTextRect();\r\n\t\t\t\tthis.labelRect = this.computeLabelRect();\r\n\t\t\t\tvar rectPoints = this.getPoints();\r\n\r\n\t\t\t\tvalid = true;\r\n\r\n\t\t\t\tfor (var e = 0; e < max; ++e) {\r\n\t\t\t\t\tvar element = elements[e][LABEL_KEY$1];\r\n\t\t\t\t\tif (!element) {\r\n\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tvar elPoints = element.getPoints();\r\n\r\n\t\t\t\t\tfor (var p = 0; p < rectPoints.length; ++p) {\r\n\t\t\t\t\t\tif (element.containsPoint(rectPoints[p])) {\r\n\t\t\t\t\t\t\tvalid = false;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tif(this.containsPoint(elPoints[p])) {\r\n\t\t\t\t\t\t\tvalid = false;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (!valid) {\r\n\t\t\t\t\tthis.center = positioners.moveFromAnchor(this.center, 1);\r\n\t\t\t\t\tthis.center.x += this.offset.x;\r\n\t\t\t\t\tthis.center.y += this.offset.y;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\tthis.moveLabelToOffset = function() {\r\n\t\t\tif (this.predictedOffset.x <= 0 && this.offset.x > this.predictedOffset.x) {\r\n\t\t\t\tthis.offset.x -= this.offsetStep;\r\n\t\t\t\tif (this.offset.x <= this.predictedOffset.x) {\r\n\t\t\t\t\tthis.offset.x = this.predictedOffset.x;\r\n\t\t\t\t}\r\n\t\t\t} else if (this.predictedOffset.x >= 0 && this.offset.x < this.predictedOffset.x) {\r\n\t\t\t\tthis.offset.x += this.offsetStep;\r\n\t\t\t\tif (this.offset.x >= this.predictedOffset.x) {\r\n\t\t\t\t\tthis.offset.x = this.predictedOffset.x;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t};\r\n\t}\r\n};\n\n'use strict';\r\n\r\noutlabeledCharts.init();\r\n\r\nChart$1.defaults.global.plugins.outlabels = defaults;\r\n\r\nvar LABEL_KEY = defaults.LABEL_KEY;\r\n\r\nfunction configure(dataset, options) {\r\n\tvar override = dataset.outlabels;\r\n\tvar config = {};\r\n\r\n\tif (override === false) {\r\n\t\treturn null;\r\n\t}\r\n\tif (override === true) {\r\n\t\toverride = {};\r\n\t}\r\n\r\n\treturn helpers$1.merge(config, [options, override]);\r\n}\r\n\r\nChart$1.plugins.register({\r\n\tid: 'outlabels',\r\n\r\n\tresize: function(chart, size, options) {\r\n\t\tchart.sizeChanged = true;\r\n\t},\r\n\r\n\tafterDatasetUpdate: function(chart, args, options) {\r\n\t\tvar labels = chart.config.data.labels;\r\n\t\tvar dataset = chart.data.datasets[args.index];\r\n\t\tvar config = configure(dataset, options);\r\n\t\tvar display = config && config.display;\r\n\t\tvar elements = args.meta.data || [];\r\n\t\tvar ctx = chart.ctx;\r\n\t\tvar el, label, percent, newLabel, context, i;\r\n\r\n\t\tctx.save();\r\n\r\n\t\tfor (i = 0; i < elements.length; ++i) {\r\n\t\t\tel = elements[i];\r\n\t\t\tlabel = el[LABEL_KEY];\r\n\t\t\tpercent = dataset.data[i] / args.meta.total;\r\n\t\t\tnewLabel = null;\r\n\r\n\t\t\tif (display && el && !el.hidden) {\r\n\t\t\t\ttry {\r\n\t\t\t\t\tcontext = {\r\n\t\t\t\t\t\tchart: chart,\r\n\t\t\t\t\t\tdataIndex: i,\r\n\t\t\t\t\t\tdataset: dataset,\r\n\t\t\t\t\t\tlabels: labels,\r\n\t\t\t\t\t\tdatasetIndex: args.index,\r\n\t\t\t\t\t\tpercent: percent\r\n\t\t\t\t\t};\r\n\t\t\t\t\tnewLabel = new classes.OutLabel(el, i, ctx, config, context);\r\n\t\t\t\t} catch(e) {\r\n\t\t\t\t\tnewLabel = null;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif (\r\n\t\t\t\tlabel && \r\n\t\t\t\tnewLabel && \r\n\t\t\t\t!chart.sizeChanged &&\r\n\t\t\t\t(label.label === newLabel.label) && \r\n\t\t\t\t(label.encodedText === newLabel.encodedText)\r\n\t\t\t) {\r\n\t\t\t\tnewLabel.offset = label.offset;\r\n\t\t\t}\r\n\r\n\t\t\tel[LABEL_KEY] = newLabel;\r\n\t\t}\r\n\r\n\t\tctx.restore();\r\n\t\tchart.sizeChanged = false;\r\n\t},\r\n\tafterDatasetDraw: function(chart, args) {\r\n\t\tvar elements = args.meta.data || [];\r\n\t\tvar ctx = chart.ctx;\r\n\t\tvar el, label, index;\r\n\r\n\t\tfor (var i = 0; i < 2 * elements.length; ++i) {\r\n\t\t\tindex = i < elements.length ? i : i - elements.length;\r\n\r\n\t\t\tel = elements[index];\r\n\t\t\tlabel = el[LABEL_KEY];\r\n\t\t\tif (!label) {\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\t\t\tif (i < elements.length) {\r\n\t\t\t\tlabel.update(el._view, elements, i);\r\n\t\t\t\tlabel.drawLine(ctx);\r\n\t\t\t} else {\r\n\t\t\t\tlabel.draw(ctx);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n});\n\n})));\n",null]}