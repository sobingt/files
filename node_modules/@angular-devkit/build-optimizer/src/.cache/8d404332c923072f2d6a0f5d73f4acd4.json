{"remainingRequest":"/home/vishwvir/company_projects/tata/web/ui_propensity/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js??ref--8-1!/home/vishwvir/company_projects/tata/web/ui_propensity/node_modules/ng2-semantic-ui/dist/modules/transition/classes/transition-controller.js","dependencies":[{"path":"/home/vishwvir/company_projects/tata/web/ui_propensity/node_modules/ng2-semantic-ui/dist/modules/transition/classes/transition-controller.js","mtime":1596454950000},{"path":"/home/vishwvir/company_projects/tata/web/ui_propensity/node_modules/cache-loader/dist/cjs.js","mtime":1596454942000},{"path":"/home/vishwvir/company_projects/tata/web/ui_propensity/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js","mtime":1596454940000}],"contextDependencies":[],"result":["import { TransitionDirection } from \"./transition\";\nvar TransitionController = /** @class */ /*@__PURE__*/ (function () {\n    function TransitionController(isInitiallyVisible, display) {\n        if (isInitiallyVisible === void 0) {\n            isInitiallyVisible = true;\n        }\n        if (display === void 0) {\n            display = \"block\";\n        }\n        // isInitiallyVisible sets whether the element starts out visible.\n        this._isVisible = isInitiallyVisible;\n        this._isHidden = !this._isVisible;\n        this._display = display;\n        this._queue = [];\n        this._isAnimating = false;\n    }\n    Object.defineProperty(TransitionController.prototype, \"_isReady\", {\n        // Used to delay animations until we have an element to animate.\n        get: \n        // Used to delay animations until we have an element to animate.\n        function () {\n            return this._renderer != undefined && this._element != undefined && this._changeDetector != undefined;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(TransitionController.prototype, \"isAnimating\", {\n        get: function () {\n            return this._isAnimating;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(TransitionController.prototype, \"isVisible\", {\n        get: function () {\n            return this._isVisible;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(TransitionController.prototype, \"isHidden\", {\n        get: function () {\n            return this._isHidden;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(TransitionController.prototype, \"_queueFirst\", {\n        // Gets the first transition in the queue.\n        get: \n        // Gets the first transition in the queue.\n        function () {\n            return this._queue[0];\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(TransitionController.prototype, \"_queueLast\", {\n        // Gets the last transition in the queue.\n        get: \n        // Gets the last transition in the queue.\n        function () {\n            return this._queue[this._queue.length - 1];\n        },\n        enumerable: true,\n        configurable: true\n    });\n    // Sets the renderer to be used for animating.\n    // Sets the renderer to be used for animating.\n    TransitionController.prototype.registerRenderer =\n        // Sets the renderer to be used for animating.\n        function (renderer) {\n            this._renderer = renderer;\n            this.performTransition();\n        };\n    // Sets the element to perform the animations on.\n    // Sets the element to perform the animations on.\n    TransitionController.prototype.registerElement =\n        // Sets the element to perform the animations on.\n        function (element) {\n            this._element = element;\n            this.performTransition();\n        };\n    // Sets the change detector to detect changes when using ChangeDetectionStrategy.OnPush.\n    // Sets the change detector to detect changes when using ChangeDetectionStrategy.OnPush.\n    TransitionController.prototype.registerChangeDetector =\n        // Sets the change detector to detect changes when using ChangeDetectionStrategy.OnPush.\n        function (changeDetector) {\n            this._changeDetector = changeDetector;\n            this.performTransition();\n        };\n    TransitionController.prototype.animate = function (transition) {\n        // Test if transition is one of the list that doesn't change the visible state.\n        // Should these eventually become classes?\n        var isDirectionless = [\"jiggle\", \"flash\", \"shake\", \"pulse\", \"tada\", \"bounce\"].indexOf(transition.type) !== -1;\n        if (isDirectionless) {\n            transition.direction = TransitionDirection.Static;\n        }\n        else if (transition.direction == undefined || transition.direction === TransitionDirection.Either) {\n            // Set the direction to the opposite of the current visible state automatically if not set, or set to either direction.\n            transition.direction = this._isVisible ? TransitionDirection.Out : TransitionDirection.In;\n            if (this._queueLast) {\n                // If there is an transition in the queue already, set the direction to the opposite of the direction of that transition.\n                if (this._queueLast.direction === TransitionDirection.In) {\n                    transition.direction = TransitionDirection.Out;\n                }\n                else if (this._queueLast.direction === TransitionDirection.Out) {\n                    transition.direction = TransitionDirection.In;\n                }\n            }\n        }\n        // Store the transition in the queue before attempting to perform it.\n        this._queue.push(transition);\n        this.performTransition();\n    };\n    TransitionController.prototype.performTransition = function () {\n        var _this = this;\n        if (!this._isReady || this._isAnimating || !this._queueFirst) {\n            // Don't transition until we are ready, or if we are animating, or if there aren't any transitions in the queue.\n            return;\n        }\n        this._isAnimating = true;\n        var transition = this._queueFirst;\n        // Set the Semantic UI classes for transitioning.\n        transition.classes.forEach(function (c) { return _this._renderer.addClass(_this._element, c); });\n        this._renderer.addClass(this._element, \"animating\");\n        this._renderer.addClass(this._element, transition.directionClass);\n        // Set the Semantic UI styles for transitioning.\n        this._renderer.setStyle(this._element, \"animationDuration\", transition.duration + \"ms\");\n        this._renderer.setStyle(this._element, \"display\", this._display);\n        if (transition.direction === TransitionDirection.In) {\n            // Unset hidden if we are transitioning in.\n            this._isHidden = false;\n        }\n        // Wait the length of the animation before calling the complete callback.\n        this._animationTimeout = window.setTimeout(function () { return _this.finishTransition(transition); }, transition.duration);\n    };\n    // Called when a transition has completed.\n    // Called when a transition has completed.\n    TransitionController.prototype.finishTransition =\n        // Called when a transition has completed.\n        function (transition) {\n            var _this = this;\n            // Unset the Semantic UI classes & styles for transitioning.\n            transition.classes.forEach(function (c) { return _this._renderer.removeClass(_this._element, c); });\n            this._renderer.removeClass(this._element, \"animating\");\n            this._renderer.removeClass(this._element, transition.directionClass);\n            this._renderer.removeStyle(this._element, \"animationDuration\");\n            this._renderer.removeStyle(this._element, \"display\");\n            if (transition.direction === TransitionDirection.In) {\n                // If we have just animated in, we are now visible.\n                this._isVisible = true;\n            }\n            else if (transition.direction === TransitionDirection.Out) {\n                // If we have transitioned out, we should be invisible and hidden.\n                this._isVisible = false;\n                this._isHidden = true;\n            }\n            if (transition.onComplete) {\n                // Call the user-defined transition callback.\n                transition.onComplete();\n            }\n            // Delete the transition from the queue.\n            this._queue.shift();\n            this._isAnimating = false;\n            this._changeDetector.markForCheck();\n            // Immediately attempt to perform another transition.\n            this.performTransition();\n        };\n    // Stops the current transition, leaves the rest of the queue intact.\n    // Stops the current transition, leaves the rest of the queue intact.\n    TransitionController.prototype.stop =\n        // Stops the current transition, leaves the rest of the queue intact.\n        function (transition) {\n            if (transition === void 0) {\n                transition = this._queueFirst;\n            }\n            if (!transition || !this._isAnimating) {\n                return;\n            }\n            clearTimeout(this._animationTimeout);\n            this.finishTransition(transition);\n        };\n    // Stops the current transition, and empties the queue.\n    // Stops the current transition, and empties the queue.\n    TransitionController.prototype.stopAll =\n        // Stops the current transition, and empties the queue.\n        function () {\n            this.clearQueue();\n            this.stop();\n        };\n    // Empties the transition queue but carries on with the current transition.\n    // Empties the transition queue but carries on with the current transition.\n    TransitionController.prototype.clearQueue =\n        // Empties the transition queue but carries on with the current transition.\n        function () {\n            if (this.isAnimating) {\n                this._queue = [this._queueFirst];\n                return;\n            }\n            this._queue = [];\n        };\n    return TransitionController;\n}());\nexport { TransitionController };\n//# sourceMappingURL=transition-controller.js.map\n",null]}