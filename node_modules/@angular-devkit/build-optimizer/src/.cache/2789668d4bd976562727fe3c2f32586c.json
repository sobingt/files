{"remainingRequest":"/home/vishwvir/company_projects/tata/web/ui_propensity/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js??ref--8-1!/home/vishwvir/company_projects/tata/web/ui_propensity/node_modules/jspdf-autotable/dist/jspdf.plugin.autotable.js","dependencies":[{"path":"/home/vishwvir/company_projects/tata/web/ui_propensity/node_modules/jspdf-autotable/dist/jspdf.plugin.autotable.js","mtime":1596454950000},{"path":"/home/vishwvir/company_projects/tata/web/ui_propensity/node_modules/cache-loader/dist/cjs.js","mtime":1596454942000},{"path":"/home/vishwvir/company_projects/tata/web/ui_propensity/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js","mtime":1596454940000}],"contextDependencies":[],"result":["/*!\n *\n *             jsPDF AutoTable plugin v3.2.11\n *\n *             Copyright (c) 2014 Simon Bengtsson, https://github.com/simonbengtsson/jsPDF-AutoTable\n *             Licensed under the MIT License.\n *             http://opensource.org/licenses/mit-license\n *\n *             * /if (typeof window === 'object') window.jspdfAutoTableVersion = '\" + newVersion + \"';/*\"\n *\n */\n(function webpackUniversalModuleDefinition(root, factory) {\n    if (typeof exports === 'object' && typeof module === 'object')\n        module.exports = factory(require(\"jspdf\"));\n    else if (typeof define === 'function' && define.amd)\n        define([\"jspdf\"], factory);\n    else {\n        var a = typeof exports === 'object' ? factory(require(\"jspdf\")) : factory(root[\"jsPDF\"]);\n        for (var i in a)\n            (typeof exports === 'object' ? exports : root)[i] = a[i];\n    }\n})(window, function (__WEBPACK_EXTERNAL_MODULE__7__) {\n    return /******/ (function (modules) {\n        /******/ // The module cache\n        /******/ var installedModules = {};\n        /******/\n        /******/ // The require function\n        /******/ function __webpack_require__(moduleId) {\n            /******/\n            /******/ // Check if module is in cache\n            /******/ if (installedModules[moduleId]) {\n                /******/ return installedModules[moduleId].exports;\n                /******/ }\n            /******/ // Create a new module (and put it into the cache)\n            /******/ var module = installedModules[moduleId] = {\n                /******/ i: moduleId,\n                /******/ l: false,\n                /******/ exports: {}\n                /******/ \n            };\n            /******/\n            /******/ // Execute the module function\n            /******/ modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n            /******/\n            /******/ // Flag the module as loaded\n            /******/ module.l = true;\n            /******/\n            /******/ // Return the exports of the module\n            /******/ return module.exports;\n            /******/ \n        }\n        /******/\n        /******/\n        /******/ // expose the modules object (__webpack_modules__)\n        /******/ __webpack_require__.m = modules;\n        /******/\n        /******/ // expose the module cache\n        /******/ __webpack_require__.c = installedModules;\n        /******/\n        /******/ // define getter function for harmony exports\n        /******/ __webpack_require__.d = function (exports, name, getter) {\n            /******/ if (!__webpack_require__.o(exports, name)) {\n                /******/ Object.defineProperty(exports, name, { enumerable: true, get: getter });\n                /******/ }\n            /******/ \n        };\n        /******/\n        /******/ // define __esModule on exports\n        /******/ __webpack_require__.r = function (exports) {\n            /******/ if (typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n                /******/ Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n                /******/ }\n            /******/ Object.defineProperty(exports, '__esModule', { value: true });\n            /******/ \n        };\n        /******/\n        /******/ // create a fake namespace object\n        /******/ // mode & 1: value is a module id, require it\n        /******/ // mode & 2: merge all properties of value into the ns\n        /******/ // mode & 4: return value when already ns object\n        /******/ // mode & 8|1: behave like require\n        /******/ __webpack_require__.t = function (value, mode) {\n            /******/ if (mode & 1)\n                value = __webpack_require__(value);\n            /******/ if (mode & 8)\n                return value;\n            /******/ if ((mode & 4) && typeof value === 'object' && value && value.__esModule)\n                return value;\n            /******/ var ns = Object.create(null);\n            /******/ __webpack_require__.r(ns);\n            /******/ Object.defineProperty(ns, 'default', { enumerable: true, value: value });\n            /******/ if (mode & 2 && typeof value != 'string')\n                for (var key in value)\n                    __webpack_require__.d(ns, key, function (key) { return value[key]; }.bind(null, key));\n            /******/ return ns;\n            /******/ \n        };\n        /******/\n        /******/ // getDefaultExport function for compatibility with non-harmony modules\n        /******/ __webpack_require__.n = function (module) {\n            /******/ var getter = module && module.__esModule ?\n                /******/ function getDefault() { return module['default']; } :\n                /******/ function getModuleExports() { return module; };\n            /******/ __webpack_require__.d(getter, 'a', getter);\n            /******/ return getter;\n            /******/ \n        };\n        /******/\n        /******/ // Object.prototype.hasOwnProperty.call\n        /******/ __webpack_require__.o = function (object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n        /******/\n        /******/ // __webpack_public_path__\n        /******/ __webpack_require__.p = \"\";\n        /******/\n        /******/\n        /******/ // Load entry module and return exports\n        /******/ return __webpack_require__(__webpack_require__.s = 8);\n        /******/ \n    })([\n        /* 0 */\n        /***/ (function (module, exports, __webpack_require__) {\n            \"use strict\";\n            Object.defineProperty(exports, \"__esModule\", { value: true });\n            var defaultsDocument = null;\n            var previousTableState;\n            var tableState = null;\n            exports.globalDefaults = {};\n            exports.documentDefaults = {};\n            function default_1() {\n                return tableState;\n            }\n            exports.default = default_1;\n            function getGlobalOptions() {\n                return exports.globalDefaults;\n            }\n            exports.getGlobalOptions = getGlobalOptions;\n            function getDocumentOptions() {\n                return exports.documentDefaults;\n            }\n            exports.getDocumentOptions = getDocumentOptions;\n            var TableState = /** @class */ /*@__PURE__*/ (function () {\n                function TableState(doc) {\n                    this.doc = doc;\n                }\n                TableState.prototype.pageHeight = function () {\n                    return this.pageSize().height;\n                };\n                ;\n                TableState.prototype.pageWidth = function () {\n                    return this.pageSize().width;\n                };\n                ;\n                TableState.prototype.pageSize = function () {\n                    var pageSize = this.doc.internal.pageSize;\n                    // JSPDF 1.4 uses get functions instead of properties on pageSize\n                    if (pageSize.width == null) {\n                        pageSize = {\n                            width: pageSize.getWidth(),\n                            height: pageSize.getHeight()\n                        };\n                    }\n                    return pageSize;\n                };\n                ;\n                TableState.prototype.scaleFactor = function () {\n                    return this.doc.internal.scaleFactor;\n                };\n                ;\n                TableState.prototype.pageNumber = function () {\n                    var pageInfo = this.doc.internal.getCurrentPageInfo();\n                    if (!pageInfo) {\n                        // Only recent versions of jspdf has pageInfo\n                        return this.doc.internal.getNumberOfPages();\n                    }\n                    return pageInfo.pageNumber;\n                };\n                return TableState;\n            }());\n            function setupState(doc) {\n                previousTableState = tableState;\n                tableState = new TableState(doc);\n                if (doc !== defaultsDocument) {\n                    defaultsDocument = doc;\n                    exports.documentDefaults = {};\n                }\n            }\n            exports.setupState = setupState;\n            function resetState() {\n                tableState = previousTableState;\n            }\n            exports.resetState = resetState;\n            function setDefaults(defaults, doc) {\n                if (doc === void 0) {\n                    doc = null;\n                }\n                if (doc) {\n                    exports.documentDefaults = defaults || {};\n                    defaultsDocument = doc;\n                }\n                else {\n                    exports.globalDefaults = defaults || {};\n                }\n            }\n            exports.setDefaults = setDefaults;\n            /***/ \n        }),\n        /* 1 */\n        /***/ (function (module, exports, __webpack_require__) {\n            \"use strict\";\n            var __spreadArrays = (this && this.__spreadArrays) || function () {\n                for (var s = 0, i = 0, il = arguments.length; i < il; i++)\n                    s += arguments[i].length;\n                for (var r = Array(s), k = 0, i = 0; i < il; i++)\n                    for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\n                        r[k] = a[j];\n                return r;\n            };\n            Object.defineProperty(exports, \"__esModule\", { value: true });\n            var config_1 = __webpack_require__(2);\n            var state_1 = __webpack_require__(0);\n            var polyfills_1 = __webpack_require__(3);\n            function getStringWidth(text, styles) {\n                applyStyles(styles);\n                var textArr = Array.isArray(text) ? text : [text];\n                var widestLineWidth = textArr\n                    .map(function (text) { return state_1.default().doc.getTextWidth(text); })\n                    // Shave off a few digits for potential improvement in width calculation\n                    .map(function (val) { return Math.floor(val * 10000) / 10000; })\n                    .reduce(function (a, b) { return Math.max(a, b); }, 0);\n                var fontSize = styles.fontSize / state_1.default().scaleFactor();\n                return widestLineWidth;\n            }\n            exports.getStringWidth = getStringWidth;\n            /**\n             * Ellipsize the text to fit in the width\n             */\n            function ellipsize(text, width, styles, ellipsizeStr) {\n                if (ellipsizeStr === void 0) {\n                    ellipsizeStr = '...';\n                }\n                if (Array.isArray(text)) {\n                    var value_1 = [];\n                    text.forEach(function (str, i) {\n                        value_1[i] = ellipsize(str, width, styles, ellipsizeStr);\n                    });\n                    return value_1;\n                }\n                var precision = 10000 * state_1.default().scaleFactor();\n                width = Math.ceil(width * precision) / precision;\n                if (width >= getStringWidth(text, styles)) {\n                    return text;\n                }\n                while (width < getStringWidth(text + ellipsizeStr, styles)) {\n                    if (text.length <= 1) {\n                        break;\n                    }\n                    text = text.substring(0, text.length - 1);\n                }\n                return text.trim() + ellipsizeStr;\n            }\n            exports.ellipsize = ellipsize;\n            function addTableBorder() {\n                var table = state_1.default().table;\n                var styles = { lineWidth: table.settings.tableLineWidth, lineColor: table.settings.tableLineColor };\n                applyStyles(styles);\n                var fs = getFillStyle(styles);\n                if (fs) {\n                    state_1.default().doc.rect(table.pageStartX, table.pageStartY, table.width, table.cursor.y - table.pageStartY, fs);\n                }\n            }\n            exports.addTableBorder = addTableBorder;\n            function getFillStyle(styles) {\n                var drawLine = styles.lineWidth > 0;\n                var drawBackground = styles.fillColor || styles.fillColor === 0;\n                if (drawLine && drawBackground) {\n                    return 'DF'; // Fill then stroke\n                }\n                else if (drawLine) {\n                    return 'S'; // Only stroke (transparent background)\n                }\n                else if (drawBackground) {\n                    return 'F'; // Only fill, no stroke\n                }\n                else {\n                    return false;\n                }\n            }\n            exports.getFillStyle = getFillStyle;\n            function applyUserStyles() {\n                applyStyles(state_1.default().table.userStyles);\n            }\n            exports.applyUserStyles = applyUserStyles;\n            function applyStyles(styles) {\n                var doc = state_1.default().doc;\n                var styleModifiers = {\n                    fillColor: doc.setFillColor,\n                    textColor: doc.setTextColor,\n                    fontStyle: doc.setFontStyle,\n                    lineColor: doc.setDrawColor,\n                    lineWidth: doc.setLineWidth,\n                    font: doc.setFont,\n                    fontSize: doc.setFontSize\n                };\n                Object.keys(styleModifiers).forEach(function (name) {\n                    var style = styles[name];\n                    var modifier = styleModifiers[name];\n                    if (typeof style !== 'undefined') {\n                        if (Array.isArray(style)) {\n                            modifier.apply(this, style);\n                        }\n                        else {\n                            modifier(style);\n                        }\n                    }\n                });\n            }\n            exports.applyStyles = applyStyles;\n            // This is messy, only keep array and number format the next major version\n            function marginOrPadding(value, defaultValue) {\n                var newValue = {};\n                if (Array.isArray(value)) {\n                    if (value.length >= 4) {\n                        newValue = { 'top': value[0], 'right': value[1], 'bottom': value[2], 'left': value[3] };\n                    }\n                    else if (value.length === 3) {\n                        newValue = { 'top': value[0], 'right': value[1], 'bottom': value[2], 'left': value[1] };\n                    }\n                    else if (value.length === 2) {\n                        newValue = { 'top': value[0], 'right': value[1], 'bottom': value[0], 'left': value[1] };\n                    }\n                    else if (value.length === 1) {\n                        value = value[0];\n                    }\n                    else {\n                        value = defaultValue;\n                    }\n                }\n                else if (typeof value === 'object') {\n                    if (value['vertical']) {\n                        value['top'] = value['vertical'];\n                        value['bottom'] = value['vertical'];\n                    }\n                    if (value['horizontal']) {\n                        value['right'] = value['horizontal'];\n                        value['left'] = value['horizontal'];\n                    }\n                    for (var _i = 0, _a = ['top', 'right', 'bottom', 'left']; _i < _a.length; _i++) {\n                        var side = _a[_i];\n                        newValue[side] = (value[side] || value[side] === 0) ? value[side] : defaultValue;\n                    }\n                }\n                if (typeof value === 'number') {\n                    newValue = { 'top': value, 'right': value, 'bottom': value, 'left': value };\n                }\n                return newValue;\n            }\n            exports.marginOrPadding = marginOrPadding;\n            function styles(styles) {\n                styles = Array.isArray(styles) ? styles : [styles];\n                return polyfills_1.assign.apply(void 0, __spreadArrays([config_1.defaultStyles()], styles));\n            }\n            exports.styles = styles;\n            /***/ \n        }),\n        /* 2 */\n        /***/ (function (module, exports, __webpack_require__) {\n            \"use strict\";\n            Object.defineProperty(exports, \"__esModule\", { value: true });\n            /**\n             * Ratio between font size and font height. The number comes from jspdf's source code\n             */\n            exports.FONT_ROW_RATIO = 1.15;\n            var state_1 = __webpack_require__(0);\n            function defaultConfig() {\n                return {\n                    // Html content\n                    html: null,\n                    // Custom content\n                    head: null,\n                    body: null,\n                    foot: null,\n                    // Properties\n                    includeHiddenHtml: false,\n                    startY: null,\n                    margin: 40 / state_1.default().scaleFactor(),\n                    pageBreak: 'auto',\n                    rowPageBreak: 'auto',\n                    tableWidth: 'auto',\n                    showHead: 'everyPage',\n                    showFoot: 'everyPage',\n                    tableLineWidth: 0,\n                    tableLineColor: 200,\n                    tableId: null,\n                    // Styling\n                    theme: 'striped',\n                    useCss: false,\n                    styles: {},\n                    headStyles: {},\n                    bodyStyles: {},\n                    footStyles: {},\n                    alternateRowStyles: {},\n                    columnStyles: {},\n                    // Hooks\n                    // Use to change the content of the cell before width calculations etc are performed\n                    didParseCell: function (data) {\n                    },\n                    willDrawCell: function (data) {\n                    },\n                    // Use to draw additional content such as images in table cells\n                    didDrawCell: function (data) {\n                    },\n                    // Use to draw additional content to each page such as headers and footers\n                    didDrawPage: function (data) {\n                    },\n                };\n            }\n            exports.defaultConfig = defaultConfig;\n            // Base style for all themes\n            function defaultStyles() {\n                return {\n                    font: \"helvetica\",\n                    fontStyle: 'normal',\n                    overflow: 'linebreak',\n                    fillColor: false,\n                    textColor: 20,\n                    halign: 'left',\n                    valign: 'top',\n                    fontSize: 10,\n                    cellPadding: 5 / state_1.default().scaleFactor(),\n                    lineColor: 200,\n                    lineWidth: 0 / state_1.default().scaleFactor(),\n                    cellWidth: 'auto',\n                    minCellHeight: 0\n                };\n            }\n            exports.defaultStyles = defaultStyles;\n            /**\n             * Styles for the themes (overriding the default styles)\n             */\n            function getTheme(name) {\n                var themes = {\n                    'striped': {\n                        table: { fillColor: 255, textColor: 80, fontStyle: 'normal' },\n                        head: { textColor: 255, fillColor: [41, 128, 185], fontStyle: 'bold' },\n                        body: {},\n                        foot: { textColor: 255, fillColor: [41, 128, 185], fontStyle: 'bold' },\n                        alternateRow: { fillColor: 245 }\n                    },\n                    'grid': {\n                        table: { fillColor: 255, textColor: 80, fontStyle: 'normal', lineWidth: 0.1 },\n                        head: { textColor: 255, fillColor: [26, 188, 156], fontStyle: 'bold', lineWidth: 0 },\n                        body: {},\n                        foot: { textColor: 255, fillColor: [26, 188, 156], fontStyle: 'bold', lineWidth: 0 },\n                        alternateRow: {}\n                    },\n                    'plain': {\n                        head: { fontStyle: 'bold' },\n                        foot: { fontStyle: 'bold' }\n                    }\n                };\n                return themes[name];\n            }\n            exports.getTheme = getTheme;\n            /***/ \n        }),\n        /* 3 */\n        /***/ (function (module, exports, __webpack_require__) {\n            \"use strict\";\n            /*\n             * Include common small polyfills instead of requiring the user to to do it\n             */\n            Object.defineProperty(exports, \"__esModule\", { value: true });\n            // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign\n            function assign(target) {\n                'use strict';\n                var varArgs = [];\n                for (var _i = 1; _i < arguments.length; _i++) {\n                    varArgs[_i - 1] = arguments[_i];\n                }\n                if (target == null) { // TypeError if undefined or null\n                    throw new TypeError('Cannot convert undefined or null to object');\n                }\n                var to = Object(target);\n                for (var index = 1; index < arguments.length; index++) {\n                    var nextSource = arguments[index];\n                    if (nextSource != null) { // Skip over if undefined or null\n                        for (var nextKey in nextSource) {\n                            // Avoid bugs when hasOwnProperty is shadowed\n                            if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {\n                                to[nextKey] = nextSource[nextKey];\n                            }\n                        }\n                    }\n                }\n                return to;\n            }\n            exports.assign = assign;\n            /***/ \n        }),\n        /* 4 */\n        /***/ (function (module, exports, __webpack_require__) {\n            \"use strict\";\n            Object.defineProperty(exports, \"__esModule\", { value: true });\n            var config_1 = __webpack_require__(2);\n            var state_1 = __webpack_require__(0);\n            var HookData_1 = __webpack_require__(10);\n            var common_1 = __webpack_require__(1);\n            var assign = __webpack_require__(5);\n            var CellHooks = /** @class */ /*@__PURE__*/ (function () {\n                function CellHooks() {\n                    this.didParseCell = [];\n                    this.willDrawCell = [];\n                    this.didDrawCell = [];\n                    this.didDrawPage = [];\n                }\n                return CellHooks;\n            }());\n            var Table = /** @class */ /*@__PURE__*/ (function () {\n                function Table() {\n                    this.columns = [];\n                    this.head = [];\n                    this.body = [];\n                    this.foot = [];\n                    this.height = 0;\n                    this.width = 0;\n                    this.preferredWidth = 0;\n                    this.wrappedWidth = 0;\n                    this.minWidth = 0;\n                    this.headHeight = 0;\n                    this.footHeight = 0;\n                    this.startPageNumber = 1;\n                    this.pageNumber = 1;\n                    this.styles = {\n                        styles: {},\n                        headStyles: {},\n                        bodyStyles: {},\n                        footStyles: {},\n                        alternateRowStyles: {},\n                        columnStyles: {},\n                    };\n                    this.cellHooks = new CellHooks();\n                }\n                Object.defineProperty(Table.prototype, \"pageCount\", {\n                    get: function () {\n                        return this.pageNumber;\n                    },\n                    enumerable: true,\n                    configurable: true\n                });\n                Table.prototype.allRows = function () {\n                    return this.head.concat(this.body).concat(this.foot);\n                };\n                Table.prototype.callCellHooks = function (handlers, cell, row, column) {\n                    for (var _i = 0, handlers_1 = handlers; _i < handlers_1.length; _i++) {\n                        var handler = handlers_1[_i];\n                        if (handler(new HookData_1.CellHookData(cell, row, column)) === false) {\n                            return false;\n                        }\n                    }\n                    return true;\n                };\n                Table.prototype.callEndPageHooks = function () {\n                    common_1.applyUserStyles();\n                    for (var _i = 0, _a = this.cellHooks.didDrawPage; _i < _a.length; _i++) {\n                        var handler = _a[_i];\n                        handler(new HookData_1.HookData());\n                    }\n                };\n                Table.prototype.margin = function (side) {\n                    return common_1.marginOrPadding(this.settings.margin, config_1.defaultConfig().margin)[side];\n                };\n                return Table;\n            }());\n            exports.Table = Table;\n            var Row = /** @class */ /*@__PURE__*/ (function () {\n                function Row(raw, index, section) {\n                    this.cells = {};\n                    this.height = 0;\n                    this.maxCellHeight = 0;\n                    this.pageNumber = 1;\n                    this.spansMultiplePages = false;\n                    this.raw = raw;\n                    if (raw._element) {\n                        this.raw = raw._element;\n                    }\n                    this.index = index;\n                    this.section = section;\n                }\n                Object.defineProperty(Row.prototype, \"pageCount\", {\n                    get: function () {\n                        return this.pageNumber;\n                    },\n                    enumerable: true,\n                    configurable: true\n                });\n                Row.prototype.canEntireRowFit = function (height) {\n                    return this.maxCellHeight <= height;\n                };\n                Row.prototype.getMinimumRowHeight = function () {\n                    var _this = this;\n                    return state_1.default().table.columns.reduce(function (acc, column) {\n                        var cell = _this.cells[column.index];\n                        if (!cell)\n                            return 0;\n                        var fontHeight = cell.styles.fontSize / state_1.default().scaleFactor() * config_1.FONT_ROW_RATIO;\n                        var vPadding = cell.padding('vertical');\n                        var oneRowHeight = vPadding + fontHeight;\n                        return oneRowHeight > acc ? oneRowHeight : acc;\n                    }, 0);\n                };\n                return Row;\n            }());\n            exports.Row = Row;\n            var Cell = /** @class */ /*@__PURE__*/ (function () {\n                function Cell(raw, themeStyles, section) {\n                    this.contentHeight = 0;\n                    this.contentWidth = 0;\n                    this.wrappedWidth = 0;\n                    this.minWidth = 0;\n                    this.textPos = {};\n                    this.height = 0;\n                    this.width = 0;\n                    this.rowSpan = raw && raw.rowSpan || 1;\n                    this.colSpan = raw && raw.colSpan || 1;\n                    this.styles = assign(themeStyles, raw && raw.styles || {});\n                    this.section = section;\n                    var text;\n                    var content = raw && raw.content != null ? raw.content : raw;\n                    content = content && content.title != null ? content.title : content;\n                    this.raw = raw && raw._element ? raw._element : raw;\n                    // Stringify 0 and false, but not undefined or null\n                    text = content != null ? '' + content : '';\n                    var splitRegex = /\\r\\n|\\r|\\n/g;\n                    this.text = text.split(splitRegex);\n                }\n                Cell.prototype.getContentHeight = function () {\n                    var lineCount = Array.isArray(this.text) ? this.text.length : 1;\n                    var fontHeight = this.styles.fontSize / state_1.default().scaleFactor() * config_1.FONT_ROW_RATIO;\n                    return lineCount * fontHeight + this.padding('vertical');\n                };\n                Cell.prototype.padding = function (name) {\n                    var padding = common_1.marginOrPadding(this.styles.cellPadding, common_1.styles([]).cellPadding);\n                    if (name === 'vertical') {\n                        return padding.top + padding.bottom;\n                    }\n                    else if (name === 'horizontal') {\n                        return padding.left + padding.right;\n                    }\n                    else {\n                        return padding[name];\n                    }\n                };\n                return Cell;\n            }());\n            exports.Cell = Cell;\n            var Column = /** @class */ /*@__PURE__*/ (function () {\n                function Column(dataKey, raw, index) {\n                    this.preferredWidth = 0;\n                    this.minWidth = 0;\n                    this.wrappedWidth = 0;\n                    this.width = 0;\n                    this.dataKey = dataKey;\n                    this.raw = raw;\n                    this.index = index;\n                }\n                return Column;\n            }());\n            exports.Column = Column;\n            /***/ \n        }),\n        /* 5 */\n        /***/ (function (module, exports, __webpack_require__) {\n            \"use strict\";\n            /*\n            object-assign\n            (c) Sindre Sorhus\n            @license MIT\n            */\n            /* eslint-disable no-unused-vars */\n            var getOwnPropertySymbols = Object.getOwnPropertySymbols;\n            var hasOwnProperty = Object.prototype.hasOwnProperty;\n            var propIsEnumerable = Object.prototype.propertyIsEnumerable;\n            function toObject(val) {\n                if (val === null || val === undefined) {\n                    throw new TypeError('Object.assign cannot be called with null or undefined');\n                }\n                return Object(val);\n            }\n            function shouldUseNative() {\n                try {\n                    if (!Object.assign) {\n                        return false;\n                    }\n                    // Detect buggy property enumeration order in older V8 versions.\n                    // https://bugs.chromium.org/p/v8/issues/detail?id=4118\n                    var test1 = new String('abc'); // eslint-disable-line no-new-wrappers\n                    test1[5] = 'de';\n                    if (Object.getOwnPropertyNames(test1)[0] === '5') {\n                        return false;\n                    }\n                    // https://bugs.chromium.org/p/v8/issues/detail?id=3056\n                    var test2 = {};\n                    for (var i = 0; i < 10; i++) {\n                        test2['_' + String.fromCharCode(i)] = i;\n                    }\n                    var order2 = Object.getOwnPropertyNames(test2).map(function (n) {\n                        return test2[n];\n                    });\n                    if (order2.join('') !== '0123456789') {\n                        return false;\n                    }\n                    // https://bugs.chromium.org/p/v8/issues/detail?id=3056\n                    var test3 = {};\n                    'abcdefghijklmnopqrst'.split('').forEach(function (letter) {\n                        test3[letter] = letter;\n                    });\n                    if (Object.keys(Object.assign({}, test3)).join('') !==\n                        'abcdefghijklmnopqrst') {\n                        return false;\n                    }\n                    return true;\n                }\n                catch (err) {\n                    // We don't expect any of the above to throw, but better to be safe.\n                    return false;\n                }\n            }\n            module.exports = shouldUseNative() ? Object.assign : function (target, source) {\n                var from;\n                var to = toObject(target);\n                var symbols;\n                for (var s = 1; s < arguments.length; s++) {\n                    from = Object(arguments[s]);\n                    for (var key in from) {\n                        if (hasOwnProperty.call(from, key)) {\n                            to[key] = from[key];\n                        }\n                    }\n                    if (getOwnPropertySymbols) {\n                        symbols = getOwnPropertySymbols(from);\n                        for (var i = 0; i < symbols.length; i++) {\n                            if (propIsEnumerable.call(from, symbols[i])) {\n                                to[symbols[i]] = from[symbols[i]];\n                            }\n                        }\n                    }\n                }\n                return to;\n            };\n            /***/ \n        }),\n        /* 6 */\n        /***/ (function (module, exports, __webpack_require__) {\n            \"use strict\";\n            Object.defineProperty(exports, \"__esModule\", { value: true });\n            var cssParser_1 = __webpack_require__(13);\n            var state_1 = __webpack_require__(0);\n            function parseHtml(input, includeHiddenHtml, useCss) {\n                if (includeHiddenHtml === void 0) {\n                    includeHiddenHtml = false;\n                }\n                if (useCss === void 0) {\n                    useCss = false;\n                }\n                var tableElement;\n                if (typeof input === 'string') {\n                    tableElement = window.document.querySelector(input);\n                }\n                else {\n                    tableElement = input;\n                }\n                if (!tableElement) {\n                    console.error(\"Html table could not be found with input: \", input);\n                    return;\n                }\n                var head = parseTableSection(window, tableElement.tHead, includeHiddenHtml, useCss);\n                var body = [];\n                for (var i = 0; i < tableElement.tBodies.length; i++) {\n                    body = body.concat(parseTableSection(window, tableElement.tBodies[i], includeHiddenHtml, useCss));\n                }\n                var foot = parseTableSection(window, tableElement.tFoot, includeHiddenHtml, useCss);\n                return { head: head, body: body, foot: foot };\n            }\n            exports.parseHtml = parseHtml;\n            function parseTableSection(window, sectionElement, includeHidden, useCss) {\n                var results = [];\n                if (!sectionElement) {\n                    return results;\n                }\n                for (var i = 0; i < sectionElement.rows.length; i++) {\n                    var row = sectionElement.rows[i];\n                    var resultRow = [];\n                    var rowStyles = useCss ? cssParser_1.parseCss(row, state_1.default().scaleFactor(), ['cellPadding', 'lineWidth', 'lineColor']) : {};\n                    for (var i_1 = 0; i_1 < row.cells.length; i_1++) {\n                        var cell = row.cells[i_1];\n                        var style = window.getComputedStyle(cell);\n                        if (includeHidden || style.display !== 'none') {\n                            var cellStyles = useCss ? cssParser_1.parseCss(cell, state_1.default().scaleFactor()) : {};\n                            resultRow.push({\n                                rowSpan: cell.rowSpan,\n                                colSpan: cell.colSpan,\n                                styles: useCss ? cellStyles : null,\n                                _element: cell,\n                                content: parseCellContent(cell)\n                            });\n                        }\n                    }\n                    if (resultRow.length > 0 && (includeHidden || rowStyles.display !== 'none')) {\n                        resultRow._element = row;\n                        results.push(resultRow);\n                    }\n                }\n                return results;\n            }\n            function parseCellContent(orgCell) {\n                // Work on cloned node to make sure no changes are applied to html table\n                var cell = orgCell.cloneNode(true);\n                // Remove extra space and line breaks in markup to make it more similar to\n                // what would be shown in html\n                cell.innerHTML = cell.innerHTML\n                    .replace(/\\n/g, '')\n                    .replace(/ +/g, ' ');\n                // Preserve <br> tags as line breaks in the pdf\n                cell.innerHTML = cell.innerHTML\n                    .split('<br>')\n                    .map(function (part) { return part.trim(); })\n                    .join('\\n');\n                // innerText for ie\n                return cell.innerText || cell.textContent || '';\n            }\n            /***/ \n        }),\n        /* 7 */\n        /***/ (function (module, exports) {\n            module.exports = __WEBPACK_EXTERNAL_MODULE__7__;\n            /***/ \n        }),\n        /* 8 */\n        /***/ (function (module, exports, __webpack_require__) {\n            \"use strict\";\n            Object.defineProperty(exports, \"__esModule\", { value: true });\n            var tableDrawer_1 = __webpack_require__(9);\n            var widthCalculator_1 = __webpack_require__(11);\n            var inputParser_1 = __webpack_require__(12);\n            var state_1 = __webpack_require__(0);\n            __webpack_require__(15);\n            var common_1 = __webpack_require__(1);\n            var htmlParser_1 = __webpack_require__(6);\n            var jsPDF = __webpack_require__(7);\n            function autoTable() {\n                var args = [];\n                for (var _i = 0; _i < arguments.length; _i++) {\n                    args[_i] = arguments[_i];\n                }\n                state_1.setupState(this);\n                // 1. Parse and unify user input\n                var table = inputParser_1.parseInput(args);\n                // 2. Calculate preliminary table, column, row and cell dimensions\n                widthCalculator_1.calculateWidths(table);\n                // 3. Output table to pdf\n                tableDrawer_1.drawTable(table);\n                table.finalY = table.cursor.y;\n                this.previousAutoTable = table;\n                this.lastAutoTable = table;\n                this.autoTable.previous = table; // Deprecated\n                common_1.applyUserStyles();\n                state_1.resetState();\n                return this;\n            }\n            jsPDF.API.autoTable = autoTable;\n            // Assign false to enable `doc.lastAutoTable.finalY || 40` sugar;\n            jsPDF.API.lastAutoTable = false;\n            jsPDF.API.previousAutoTable = false; // deprecated in v3\n            jsPDF.API.autoTable.previous = false; // deprecated in v3\n            jsPDF.API.autoTableSetDefaults = function (defaults) {\n                state_1.setDefaults(defaults, this);\n                return this;\n            };\n            jsPDF.autoTableSetDefaults = function (defaults, doc) {\n                state_1.setDefaults(defaults, doc);\n                return this;\n            };\n            jsPDF.API.autoTableHtmlToJson = function (tableElem, includeHiddenElements) {\n                includeHiddenElements = includeHiddenElements || false;\n                if (!tableElem || !(tableElem instanceof HTMLTableElement)) {\n                    console.error(\"A HTMLTableElement has to be sent to autoTableHtmlToJson\");\n                    return null;\n                }\n                var _a = htmlParser_1.parseHtml(tableElem, includeHiddenElements, false), head = _a.head, body = _a.body, foot = _a.foot;\n                var firstRow = head[0] || body[0] || foot[0];\n                return { columns: firstRow, rows: body, data: body };\n            };\n            /**\n             * @deprecated\n             */\n            jsPDF.API.autoTableEndPosY = function () {\n                console.error(\"Use of deprecated function: autoTableEndPosY. Use doc.previousAutoTable.finalY instead.\");\n                var prev = this.previousAutoTable;\n                if (prev.cursor && typeof prev.cursor.y === 'number') {\n                    return prev.cursor.y;\n                }\n                else {\n                    return 0;\n                }\n            };\n            /**\n             * @deprecated\n             */\n            jsPDF.API.autoTableAddPageContent = function (hook) {\n                console.error(\"Use of deprecated function: autoTableAddPageContent. Use jsPDF.autoTableSetDefaults({didDrawPage: () => {}}) instead.\");\n                if (!jsPDF.API.autoTable.globalDefaults) {\n                    jsPDF.API.autoTable.globalDefaults = {};\n                }\n                jsPDF.API.autoTable.globalDefaults.addPageContent = hook;\n                return this;\n            };\n            /**\n             * @deprecated\n             */\n            jsPDF.API.autoTableAddPage = function () {\n                console.error(\"Use of deprecated function: autoTableAddPage. Use doc.addPage()\");\n                this.addPage();\n                return this;\n            };\n            /***/ \n        }),\n        /* 9 */\n        /***/ (function (module, exports, __webpack_require__) {\n            \"use strict\";\n            Object.defineProperty(exports, \"__esModule\", { value: true });\n            var config_1 = __webpack_require__(2);\n            var common_1 = __webpack_require__(1);\n            var models_1 = __webpack_require__(4);\n            var state_1 = __webpack_require__(0);\n            var assign = __webpack_require__(5);\n            function drawTable(table) {\n                var settings = table.settings;\n                table.cursor = {\n                    x: table.margin('left'),\n                    y: settings.startY == null ? table.margin('top') : settings.startY\n                };\n                var minTableBottomPos = settings.startY + table.margin('bottom') + table.headHeight + table.footHeight;\n                if (settings.pageBreak === 'avoid') {\n                    minTableBottomPos += table.height;\n                }\n                if (settings.pageBreak === 'always' || settings.startY != null && settings.startY !== false && minTableBottomPos > state_1.default().pageHeight()) {\n                    nextPage(state_1.default().doc);\n                    table.cursor.y = table.margin('top');\n                }\n                table.pageStartX = table.cursor.x;\n                table.pageStartY = table.cursor.y;\n                table.startPageNumber = state_1.default().pageNumber();\n                // An empty row used to cached cells those break through page\n                common_1.applyUserStyles();\n                if (settings.showHead === true || settings.showHead === 'firstPage' || settings.showHead === 'everyPage') {\n                    table.head.forEach(function (row) { return printRow(row); });\n                }\n                common_1.applyUserStyles();\n                table.body.forEach(function (row, index) {\n                    printFullRow(row, index === table.body.length - 1);\n                });\n                common_1.applyUserStyles();\n                if (settings.showFoot === true || settings.showFoot === 'lastPage' || settings.showFoot === 'everyPage') {\n                    table.foot.forEach(function (row) { return printRow(row); });\n                }\n                common_1.addTableBorder();\n                table.callEndPageHooks();\n            }\n            exports.drawTable = drawTable;\n            function getRemainingLineCount(cell, remainingPageSpace) {\n                var fontHeight = cell.styles.fontSize / state_1.default().scaleFactor() * config_1.FONT_ROW_RATIO;\n                var vPadding = cell.padding('vertical');\n                var remainingLines = Math.floor((remainingPageSpace - vPadding) / fontHeight);\n                return Math.max(0, remainingLines);\n            }\n            function modifyRowToFit(row, remainingPageSpace, table) {\n                var remainderRow = new models_1.Row(row.raw, -1, row.section);\n                remainderRow.spansMultiplePages = true;\n                row.spansMultiplePages = true;\n                row.height = 0;\n                row.maxCellHeight = 0;\n                for (var _i = 0, _a = table.columns; _i < _a.length; _i++) {\n                    var column = _a[_i];\n                    var cell = row.cells[column.index];\n                    if (!cell)\n                        continue;\n                    if (!Array.isArray(cell.text)) {\n                        cell.text = [cell.text];\n                    }\n                    var remainderCell = new models_1.Cell(cell.raw, {}, cell.section);\n                    remainderCell = assign(remainderCell, cell);\n                    remainderCell.textPos = assign({}, cell.textPos);\n                    remainderCell.text = [];\n                    var remainingLineCount = getRemainingLineCount(cell, remainingPageSpace);\n                    if (cell.text.length > remainingLineCount) {\n                        remainderCell.text = cell.text.splice(remainingLineCount, cell.text.length);\n                    }\n                    cell.contentHeight = cell.getContentHeight();\n                    if (cell.contentHeight > row.height) {\n                        row.height = cell.contentHeight;\n                        row.maxCellHeight = cell.contentHeight;\n                    }\n                    remainderCell.contentHeight = remainderCell.getContentHeight();\n                    if (remainderCell.contentHeight > remainderRow.height) {\n                        remainderRow.height = remainderCell.contentHeight;\n                        remainderRow.maxCellHeight = remainderCell.contentHeight;\n                    }\n                    remainderRow.cells[column.index] = remainderCell;\n                }\n                for (var _b = 0, _c = table.columns; _b < _c.length; _b++) {\n                    var column = _c[_b];\n                    var remainderCell = remainderRow.cells[column.index];\n                    if (remainderCell) {\n                        remainderCell.height = remainderRow.height;\n                    }\n                    var cell = row.cells[column.index];\n                    if (cell) {\n                        cell.height = row.height;\n                    }\n                }\n                return remainderRow;\n            }\n            function shouldPrintOnCurrentPage(row, remainingPageSpace, table) {\n                var pageHeight = state_1.default().pageHeight();\n                var marginHeight = table.margin('top') - table.margin('bottom');\n                var maxTableHeight = pageHeight - marginHeight;\n                var minRowFits = row.getMinimumRowHeight() < remainingPageSpace;\n                if (row.getMinimumRowHeight() > maxTableHeight) {\n                    console.error(\"Will not be able to print row \" + row.index + \" correctly since it's minimum height is larger than page height\");\n                    return true;\n                }\n                var rowHasRowSpanCell = table.columns.filter(function (column) {\n                    var cell = row.cells[column.index];\n                    if (!cell)\n                        return false;\n                    return cell.rowSpan > 1;\n                }).length > 0;\n                if (!minRowFits) {\n                    return false;\n                }\n                var rowHigherThanPage = row.maxCellHeight > maxTableHeight;\n                if (rowHigherThanPage) {\n                    if (rowHasRowSpanCell) {\n                        console.error(\"The content of row \" + row.index + \" will not be drawn correctly since drawing rows with a height larger than the page height and has cells with rowspans is not supported.\");\n                    }\n                    return true;\n                }\n                if (rowHasRowSpanCell) {\n                    // Currently a new page is required whenever a rowspan row don't fit a page.\n                    return false;\n                }\n                if (table.settings.rowPageBreak === 'avoid') {\n                    return false;\n                }\n                // In all other cases print the row on current page\n                return true;\n            }\n            function printFullRow(row, isLastRow) {\n                var table = state_1.default().table;\n                var remainingPageSpace = getRemainingPageSpace(isLastRow);\n                if (row.canEntireRowFit(remainingPageSpace)) {\n                    printRow(row);\n                }\n                else {\n                    if (shouldPrintOnCurrentPage(row, remainingPageSpace, table)) {\n                        var remainderRow = modifyRowToFit(row, remainingPageSpace, table);\n                        printRow(row);\n                        addPage();\n                        printFullRow(remainderRow, isLastRow);\n                    }\n                    else {\n                        addPage();\n                        printFullRow(row, isLastRow);\n                    }\n                }\n            }\n            function printRow(row) {\n                var table = state_1.default().table;\n                table.cursor.x = table.margin('left');\n                row.y = table.cursor.y;\n                row.x = table.cursor.x;\n                for (var _i = 0, _a = table.columns; _i < _a.length; _i++) {\n                    var column = _a[_i];\n                    var cell = row.cells[column.index];\n                    if (!cell) {\n                        table.cursor.x += column.width;\n                        continue;\n                    }\n                    common_1.applyStyles(cell.styles);\n                    cell.x = table.cursor.x;\n                    cell.y = row.y;\n                    if (cell.styles.valign === 'top') {\n                        cell.textPos.y = table.cursor.y + cell.padding('top');\n                    }\n                    else if (cell.styles.valign === 'bottom') {\n                        cell.textPos.y = table.cursor.y + cell.height - cell.padding('bottom');\n                    }\n                    else {\n                        cell.textPos.y = table.cursor.y + cell.height / 2;\n                    }\n                    if (cell.styles.halign === 'right') {\n                        cell.textPos.x = cell.x + cell.width - cell.padding('right');\n                    }\n                    else if (cell.styles.halign === 'center') {\n                        cell.textPos.x = cell.x + cell.width / 2;\n                    }\n                    else {\n                        cell.textPos.x = cell.x + cell.padding('left');\n                    }\n                    if (table.callCellHooks(table.cellHooks.willDrawCell, cell, row, column) === false) {\n                        table.cursor.x += column.width;\n                        continue;\n                    }\n                    var fillStyle = common_1.getFillStyle(cell.styles);\n                    if (fillStyle) {\n                        state_1.default().doc.rect(cell.x, table.cursor.y, cell.width, cell.height, fillStyle);\n                    }\n                    state_1.default().doc.autoTableText(cell.text, cell.textPos.x, cell.textPos.y, {\n                        halign: cell.styles.halign,\n                        valign: cell.styles.valign,\n                        maxWidth: Math.ceil(cell.width - cell.padding('left') - cell.padding('right'))\n                    });\n                    table.callCellHooks(table.cellHooks.didDrawCell, cell, row, column);\n                    table.cursor.x += column.width;\n                }\n                table.cursor.y += row.height;\n            }\n            function getRemainingPageSpace(isLastRow) {\n                var table = state_1.default().table;\n                var bottomContentHeight = table.margin('bottom');\n                var showFoot = table.settings.showFoot;\n                if (showFoot === true || showFoot === 'everyPage' || (showFoot === 'lastPage' && isLastRow)) {\n                    bottomContentHeight += table.footHeight;\n                }\n                return state_1.default().pageHeight() - table.cursor.y - bottomContentHeight;\n            }\n            function addPage() {\n                var table = state_1.default().table;\n                common_1.applyUserStyles();\n                if (table.settings.showFoot === true || table.settings.showFoot === 'everyPage') {\n                    table.foot.forEach(function (row) { return printRow(row); });\n                }\n                table.finalY = table.cursor.y;\n                // Add user content just before adding new page ensure it will\n                // be drawn above other things on the page\n                table.callEndPageHooks();\n                common_1.addTableBorder();\n                nextPage(state_1.default().doc);\n                table.pageNumber++;\n                table.cursor = { x: table.margin('left'), y: table.margin('top') };\n                table.pageStartX = table.cursor.x;\n                table.pageStartY = table.cursor.y;\n                if (table.settings.showHead === true || table.settings.showHead === 'everyPage') {\n                    table.head.forEach(function (row) { return printRow(row); });\n                }\n            }\n            exports.addPage = addPage;\n            function nextPage(doc) {\n                var current = state_1.default().pageNumber();\n                doc.setPage(current + 1);\n                var newCurrent = state_1.default().pageNumber();\n                if (newCurrent === current) {\n                    doc.addPage();\n                }\n            }\n            /***/ \n        }),\n        /* 10 */\n        /***/ (function (module, exports, __webpack_require__) {\n            \"use strict\";\n            var __extends = (this && this.__extends) || (function () {\n                var extendStatics = function (d, b) {\n                    extendStatics = Object.setPrototypeOf ||\n                        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n                        function (d, b) { for (var p in b)\n                            if (b.hasOwnProperty(p))\n                                d[p] = b[p]; };\n                    return extendStatics(d, b);\n                };\n                return function (d, b) {\n                    extendStatics(d, b);\n                    function __() { this.constructor = d; }\n                    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n                };\n            })();\n            Object.defineProperty(exports, \"__esModule\", { value: true });\n            var state_1 = __webpack_require__(0);\n            var HookData = /** @class */ /*@__PURE__*/ (function () {\n                function HookData() {\n                    var table = state_1.default().table;\n                    this.table = table;\n                    this.pageNumber = table.pageNumber;\n                    this.settings = table.settings;\n                    this.cursor = table.cursor;\n                    this.doc = state_1.default().doc;\n                }\n                Object.defineProperty(HookData.prototype, \"pageCount\", {\n                    get: function () {\n                        return this.pageNumber;\n                    },\n                    enumerable: true,\n                    configurable: true\n                });\n                return HookData;\n            }());\n            exports.HookData = HookData;\n            var CellHookData = /** @class */ /*@__PURE__*/ (function (_super) {\n                __extends(CellHookData, _super);\n                function CellHookData(cell, row, column) {\n                    var _this = _super.call(this) || this;\n                    _this.cell = cell;\n                    _this.row = row;\n                    _this.column = column;\n                    _this.section = row.section;\n                    return _this;\n                }\n                return CellHookData;\n            }(HookData));\n            exports.CellHookData = CellHookData;\n            /***/ \n        }),\n        /* 11 */\n        /***/ (function (module, exports, __webpack_require__) {\n            \"use strict\";\n            Object.defineProperty(exports, \"__esModule\", { value: true });\n            var common_1 = __webpack_require__(1);\n            var state_1 = __webpack_require__(0);\n            /**\n             * Calculate the column widths\n             */\n            function calculateWidths(table) {\n                var columnMinWidth = 10 / state_1.default().scaleFactor();\n                if (columnMinWidth * table.columns.length > table.width) {\n                    console.error('Columns could not fit on page');\n                }\n                else if (table.minWidth > table.width) {\n                    // Would be nice to improve the user experience of this\n                    console.error(\"Column widths too wide and can't fit page\");\n                }\n                var copy = table.columns.slice(0);\n                distributeWidth(copy, table.width, table.wrappedWidth);\n                applyColSpans(table);\n                fitContent(table);\n                applyRowSpans(table);\n            }\n            exports.calculateWidths = calculateWidths;\n            function applyRowSpans(table) {\n                var rowSpanCells = {};\n                var colRowSpansLeft = 1;\n                var all = table.allRows();\n                for (var rowIndex = 0; rowIndex < all.length; rowIndex++) {\n                    var row = all[rowIndex];\n                    for (var _i = 0, _a = table.columns; _i < _a.length; _i++) {\n                        var column = _a[_i];\n                        var data = rowSpanCells[column.index];\n                        if (colRowSpansLeft > 1) {\n                            colRowSpansLeft--;\n                            delete row.cells[column.index];\n                        }\n                        else if (data) {\n                            data.cell.height += row.height;\n                            if (data.cell.height > row.maxCellHeight) {\n                                data.row.maxCellHeight = data.cell.height;\n                            }\n                            colRowSpansLeft = data.cell.colSpan;\n                            delete row.cells[column.index];\n                            data.left--;\n                            if (data.left <= 1) {\n                                delete rowSpanCells[column.index];\n                            }\n                        }\n                        else {\n                            var cell = row.cells[column.index];\n                            if (!cell) {\n                                continue;\n                            }\n                            cell.height = row.height;\n                            if (cell.rowSpan > 1) {\n                                var remaining = all.length - rowIndex;\n                                var left = cell.rowSpan > remaining ? remaining : cell.rowSpan;\n                                rowSpanCells[column.index] = { cell: cell, left: left, row: row };\n                            }\n                        }\n                    }\n                    if (row.section === 'head') {\n                        table.headHeight += row.maxCellHeight;\n                    }\n                    if (row.section === 'foot') {\n                        table.footHeight += row.maxCellHeight;\n                    }\n                    table.height += row.height;\n                }\n            }\n            function applyColSpans(table) {\n                var all = table.allRows();\n                for (var rowIndex = 0; rowIndex < all.length; rowIndex++) {\n                    var row = all[rowIndex];\n                    var colSpanCell = null;\n                    var combinedColSpanWidth = 0;\n                    var colSpansLeft = 0;\n                    for (var columnIndex = 0; columnIndex < table.columns.length; columnIndex++) {\n                        var column = table.columns[columnIndex];\n                        var cell = null;\n                        // Width and colspan\n                        colSpansLeft -= 1;\n                        if (colSpansLeft > 1 && table.columns[columnIndex + 1]) {\n                            combinedColSpanWidth += column.width;\n                            delete row.cells[column.index];\n                            continue;\n                        }\n                        else if (colSpanCell) {\n                            cell = colSpanCell;\n                            delete row.cells[column.index];\n                            colSpanCell = null;\n                        }\n                        else {\n                            cell = row.cells[column.index];\n                            if (!cell)\n                                continue;\n                            colSpansLeft = cell.colSpan;\n                            combinedColSpanWidth = 0;\n                            if (cell.colSpan > 1) {\n                                colSpanCell = cell;\n                                combinedColSpanWidth += column.width;\n                                continue;\n                            }\n                        }\n                        cell.width = column.width + combinedColSpanWidth;\n                    }\n                }\n            }\n            function fitContent(table) {\n                var rowSpanHeight = { count: 0, height: 0 };\n                for (var _i = 0, _a = table.allRows(); _i < _a.length; _i++) {\n                    var row = _a[_i];\n                    for (var _b = 0, _c = table.columns; _b < _c.length; _b++) {\n                        var column = _c[_b];\n                        var cell = row.cells[column.index];\n                        if (!cell)\n                            continue;\n                        common_1.applyStyles(cell.styles);\n                        var textSpace = cell.width - cell.padding('horizontal');\n                        if (cell.styles.overflow === 'linebreak') {\n                            // Add one pt to textSpace to fix rounding error\n                            cell.text = state_1.default().doc.splitTextToSize(cell.text, textSpace + 1 / (state_1.default().scaleFactor() || 1), { fontSize: cell.styles.fontSize });\n                        }\n                        else if (cell.styles.overflow === 'ellipsize') {\n                            cell.text = common_1.ellipsize(cell.text, textSpace, cell.styles);\n                        }\n                        else if (cell.styles.overflow === 'hidden') {\n                            cell.text = common_1.ellipsize(cell.text, textSpace, cell.styles, '');\n                        }\n                        else if (typeof cell.styles.overflow === 'function') {\n                            cell.text = cell.styles.overflow(cell.text, textSpace);\n                        }\n                        cell.contentHeight = cell.getContentHeight();\n                        if (cell.styles.minCellHeight > cell.contentHeight) {\n                            cell.contentHeight = cell.styles.minCellHeight;\n                        }\n                        var realContentHeight = cell.contentHeight / cell.rowSpan;\n                        if (cell.rowSpan > 1 && (rowSpanHeight.count * rowSpanHeight.height < realContentHeight * cell.rowSpan)) {\n                            rowSpanHeight = { height: realContentHeight, count: cell.rowSpan };\n                        }\n                        else if (rowSpanHeight && rowSpanHeight.count > 0) {\n                            if (rowSpanHeight.height > realContentHeight) {\n                                realContentHeight = rowSpanHeight.height;\n                            }\n                        }\n                        if (realContentHeight > row.height) {\n                            row.height = realContentHeight;\n                            row.maxCellHeight = realContentHeight;\n                        }\n                    }\n                    rowSpanHeight.count--;\n                }\n            }\n            function distributeWidth(autoColumns, availableSpace, wrappedAutoColumnsWidth) {\n                var diffWidth = availableSpace - wrappedAutoColumnsWidth;\n                for (var i = 0; i < autoColumns.length; i++) {\n                    var column = autoColumns[i];\n                    var ratio = column.wrappedWidth / wrappedAutoColumnsWidth;\n                    var suggestedChange = diffWidth * ratio;\n                    var suggestedWidth = column.wrappedWidth + suggestedChange;\n                    var hasCustomWidth = false;\n                    for (var _i = 0, _a = state_1.default().table.allRows(); _i < _a.length; _i++) {\n                        var row = _a[_i];\n                        var cell = row.cells[column.index];\n                        if (cell && typeof cell.styles.cellWidth === 'number') {\n                            hasCustomWidth = true;\n                            break;\n                        }\n                    }\n                    if (suggestedWidth < column.minWidth || hasCustomWidth) {\n                        // Add 1 to minWidth as linebreaks calc otherwise sometimes made two rows\n                        column.width = column.minWidth + 1 / state_1.default().scaleFactor();\n                        wrappedAutoColumnsWidth -= column.wrappedWidth;\n                        availableSpace -= column.width;\n                        autoColumns.splice(i, 1);\n                        distributeWidth(autoColumns, availableSpace, wrappedAutoColumnsWidth);\n                        break;\n                    }\n                    column.width = suggestedWidth;\n                }\n            }\n            /***/ \n        }),\n        /* 12 */\n        /***/ (function (module, exports, __webpack_require__) {\n            \"use strict\";\n            var __spreadArrays = (this && this.__spreadArrays) || function () {\n                for (var s = 0, i = 0, il = arguments.length; i < il; i++)\n                    s += arguments[i].length;\n                for (var r = Array(s), k = 0, i = 0; i < il; i++)\n                    for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\n                        r[k] = a[j];\n                return r;\n            };\n            Object.defineProperty(exports, \"__esModule\", { value: true });\n            var models_1 = __webpack_require__(4);\n            var config_1 = __webpack_require__(2);\n            var htmlParser_1 = __webpack_require__(6);\n            var polyfills_1 = __webpack_require__(3);\n            var common_1 = __webpack_require__(1);\n            var state_1 = __webpack_require__(0);\n            var inputValidator_1 = __webpack_require__(14);\n            /**\n             * Create models from the user input\n             */\n            function parseInput(args) {\n                var tableOptions = parseUserArguments(args);\n                var globalOptions = state_1.getGlobalOptions();\n                var documentOptions = state_1.getDocumentOptions();\n                var allOptions = [globalOptions, documentOptions, tableOptions];\n                inputValidator_1.default(allOptions);\n                var table = new models_1.Table();\n                state_1.default().table = table;\n                table.id = tableOptions.tableId;\n                var doc = state_1.default().doc;\n                table.userStyles = {\n                    // Setting to black for versions of jspdf without getTextColor\n                    textColor: doc.getTextColor ? doc.getTextColor() : 0,\n                    fontSize: doc.internal.getFontSize(),\n                    fontStyle: doc.internal.getFont().fontStyle,\n                    font: doc.internal.getFont().fontName\n                };\n                var _loop_1 = function (styleProp) {\n                    var styles = allOptions.map(function (opts) { return opts[styleProp] || {}; });\n                    table.styles[styleProp] = polyfills_1.assign.apply(void 0, __spreadArrays([{}], styles));\n                };\n                // Merge styles one level deeper\n                for (var _i = 0, _a = Object.keys(table.styles); _i < _a.length; _i++) {\n                    var styleProp = _a[_i];\n                    _loop_1(styleProp);\n                }\n                // Append hooks\n                for (var _b = 0, allOptions_1 = allOptions; _b < allOptions_1.length; _b++) {\n                    var opts = allOptions_1[_b];\n                    for (var _c = 0, _d = Object.keys(table.cellHooks); _c < _d.length; _c++) {\n                        var hookName = _d[_c];\n                        if (opts && typeof opts[hookName] === 'function') {\n                            table.cellHooks[hookName].push(opts[hookName]);\n                        }\n                    }\n                }\n                table.settings = polyfills_1.assign.apply(void 0, __spreadArrays([{}, config_1.defaultConfig()], allOptions));\n                table.settings.margin = common_1.marginOrPadding(table.settings.margin, config_1.defaultConfig().margin);\n                if (table.settings.theme === 'auto') {\n                    table.settings.theme = table.settings.useCss ? 'plain' : 'striped';\n                }\n                if (table.settings.startY === false) {\n                    delete table.settings.startY;\n                }\n                var previous = state_1.default().doc.previousAutoTable;\n                var isSamePageAsPrevious = previous && previous.startPageNumber + previous.pageNumber - 1 === state_1.default().pageNumber();\n                if (table.settings.startY == null && isSamePageAsPrevious) {\n                    table.settings.startY = previous.finalY + 20 / state_1.default().scaleFactor();\n                }\n                var htmlContent = {};\n                if (table.settings.html) {\n                    htmlContent = htmlParser_1.parseHtml(table.settings.html, table.settings.includeHiddenHtml, table.settings.useCss) || {};\n                }\n                table.settings.head = htmlContent.head || table.settings.head || [];\n                table.settings.body = htmlContent.body || table.settings.body || [];\n                table.settings.foot = htmlContent.foot || table.settings.foot || [];\n                parseContent(table);\n                table.minWidth = table.columns.reduce(function (total, col) { return (total + col.minWidth); }, 0);\n                table.wrappedWidth = table.columns.reduce(function (total, col) { return (total + col.wrappedWidth); }, 0);\n                if (typeof table.settings.tableWidth === 'number') {\n                    table.width = table.settings.tableWidth;\n                }\n                else if (table.settings.tableWidth === 'wrap') {\n                    table.width = table.wrappedWidth;\n                }\n                else {\n                    table.width = state_1.default().pageWidth() - table.margin('left') - table.margin('right');\n                }\n                return table;\n            }\n            exports.parseInput = parseInput;\n            function parseUserArguments(args) {\n                // Normal initialization on format doc.autoTable(options)\n                if (args.length === 1) {\n                    return args[0];\n                }\n                else {\n                    // Deprecated initialization on format doc.autoTable(columns, body, [options])\n                    var opts = args[2] || {};\n                    opts.body = args[1];\n                    opts.columns = args[0];\n                    opts.columns.forEach(function (col) {\n                        // Support v2 title prop in v3\n                        if (typeof col === 'object' && col.header == null) {\n                            col.header = col.title;\n                        }\n                    });\n                    return opts;\n                }\n            }\n            function parseContent(table) {\n                var settings = table.settings;\n                table.columns = getTableColumns(settings);\n                var _loop_2 = function (sectionName) {\n                    var rowSpansLeftForColumn = {};\n                    var sectionRows = settings[sectionName];\n                    if (sectionRows.length === 0 && settings.columns && sectionName !== 'body') {\n                        // If no head or foot is set, try generating one with content in columns\n                        var sectionRow = generateSectionRowFromColumnData(table, sectionName);\n                        if (sectionRow) {\n                            sectionRows.push(sectionRow);\n                        }\n                    }\n                    sectionRows.forEach(function (rawRow, rowIndex) {\n                        var skippedRowForRowSpans = 0;\n                        var row = new models_1.Row(rawRow, rowIndex, sectionName);\n                        table[sectionName].push(row);\n                        var colSpansAdded = 0;\n                        var columnSpansLeft = 0;\n                        for (var _i = 0, _a = table.columns; _i < _a.length; _i++) {\n                            var column = _a[_i];\n                            if (rowSpansLeftForColumn[column.index] == null || rowSpansLeftForColumn[column.index].left === 0) {\n                                if (columnSpansLeft === 0) {\n                                    var rawCell = void 0;\n                                    if (Array.isArray(rawRow)) {\n                                        rawCell = rawRow[column.index - colSpansAdded - skippedRowForRowSpans];\n                                    }\n                                    else {\n                                        rawCell = rawRow[column.dataKey];\n                                    }\n                                    var styles = cellStyles(sectionName, column, rowIndex);\n                                    var cell = new models_1.Cell(rawCell, styles, sectionName);\n                                    // dataKey is not used internally anymore but keep for backwards compat in hooks\n                                    row.cells[column.dataKey] = cell;\n                                    row.cells[column.index] = cell;\n                                    columnSpansLeft = cell.colSpan - 1;\n                                    rowSpansLeftForColumn[column.index] = { left: cell.rowSpan - 1, times: columnSpansLeft };\n                                }\n                                else {\n                                    columnSpansLeft--;\n                                    colSpansAdded++;\n                                }\n                            }\n                            else {\n                                rowSpansLeftForColumn[column.index].left--;\n                                columnSpansLeft = rowSpansLeftForColumn[column.index].times;\n                                skippedRowForRowSpans++;\n                            }\n                        }\n                    });\n                };\n                for (var _i = 0, _a = ['head', 'body', 'foot']; _i < _a.length; _i++) {\n                    var sectionName = _a[_i];\n                    _loop_2(sectionName);\n                }\n                table.allRows().forEach(function (row) {\n                    for (var _i = 0, _a = table.columns; _i < _a.length; _i++) {\n                        var column = _a[_i];\n                        var cell = row.cells[column.index];\n                        if (!cell)\n                            continue;\n                        table.callCellHooks(table.cellHooks.didParseCell, cell, row, column);\n                        cell.contentWidth = cell.padding('horizontal') + common_1.getStringWidth(cell.text, cell.styles);\n                        if (typeof cell.styles.cellWidth === 'number') {\n                            cell.minWidth = cell.styles.cellWidth;\n                            cell.wrappedWidth = cell.styles.cellWidth;\n                        }\n                        else if (cell.styles.cellWidth === 'wrap') {\n                            cell.minWidth = cell.contentWidth;\n                            cell.wrappedWidth = cell.contentWidth;\n                        }\n                        else { // auto\n                            var defaultMinWidth = 10 / state_1.default().scaleFactor();\n                            cell.minWidth = cell.styles.minCellWidth || defaultMinWidth;\n                            cell.wrappedWidth = cell.contentWidth;\n                            if (cell.minWidth > cell.wrappedWidth) {\n                                cell.wrappedWidth = cell.minWidth;\n                            }\n                        }\n                    }\n                });\n                table.allRows().forEach(function (row) {\n                    for (var _i = 0, _a = table.columns; _i < _a.length; _i++) {\n                        var column = _a[_i];\n                        var cell = row.cells[column.index];\n                        // For now we ignore the minWidth and wrappedWidth of colspan cells when calculating colspan widths.\n                        // Could probably be improved upon however.\n                        if (cell && cell.colSpan === 1) {\n                            if (cell.wrappedWidth > column.wrappedWidth) {\n                                column.wrappedWidth = cell.wrappedWidth;\n                            }\n                            if (cell.minWidth > column.minWidth) {\n                                column.minWidth = cell.minWidth;\n                            }\n                        }\n                        else {\n                            // Respect cellWidth set in columnStyles even if there is no cells for this column\n                            // or of it the column only have colspan cells. Since the width of colspan cells\n                            // does not affect the width of columns, setting columnStyles cellWidth enables the\n                            // user to at least do it manually.\n                            // Note that this is not perfect for now since for example row and table styles are\n                            // not accounted for\n                            var columnStyles = table.styles.columnStyles[column.dataKey] || table.styles.columnStyles[column.index] || {};\n                            var cellWidth = columnStyles.cellWidth;\n                            if (cellWidth && typeof cellWidth === 'number') {\n                                column.minWidth = cellWidth;\n                                column.wrappedWidth = cellWidth;\n                            }\n                        }\n                        if (cell) {\n                            // Make sure all columns get at least min width even though width calculations are not based on them\n                            if (cell.colSpan > 1 && !column.minWidth) {\n                                column.minWidth = cell.minWidth;\n                            }\n                            if (cell.colSpan > 1 && !column.wrappedWidth) {\n                                column.wrappedWidth = cell.minWidth;\n                            }\n                            table.callCellHooks(table.cellHooks.didParseCell, cell, row, column);\n                        }\n                    }\n                });\n            }\n            function generateSectionRowFromColumnData(table, sectionName) {\n                var sectionRow = {};\n                table.columns\n                    .forEach(function (col) {\n                    var columnData = col.raw;\n                    if (sectionName === 'head') {\n                        var val = columnData && columnData.header ? columnData.header : columnData;\n                        if (val) {\n                            sectionRow[col.dataKey] = val;\n                        }\n                    }\n                    else if (sectionName === 'foot' && columnData.footer) {\n                        sectionRow[col.dataKey] = columnData.footer;\n                    }\n                });\n                return Object.keys(sectionRow).length > 0 ? sectionRow : null;\n            }\n            function getTableColumns(settings) {\n                if (settings.columns) {\n                    var cols = settings.columns.map(function (input, index) {\n                        var key = input.dataKey || input.key || index;\n                        return new models_1.Column(key, input, index);\n                    });\n                    return cols;\n                }\n                else {\n                    var firstRow_1 = settings.head[0] || settings.body[0] || settings.foot[0] || [];\n                    var columns_1 = [];\n                    Object.keys(firstRow_1)\n                        .filter(function (key) { return key !== '_element'; })\n                        .forEach(function (key) {\n                        var colSpan = firstRow_1[key] && firstRow_1[key].colSpan ? firstRow_1[key].colSpan : 1;\n                        for (var i = 0; i < colSpan; i++) {\n                            var id = void 0;\n                            if (Array.isArray(firstRow_1)) {\n                                id = columns_1.length;\n                            }\n                            else {\n                                id = key + (i > 0 ? \"_\" + i : '');\n                            }\n                            columns_1.push(new models_1.Column(id, id, columns_1.length));\n                        }\n                    });\n                    return columns_1;\n                }\n            }\n            function cellStyles(sectionName, column, rowIndex) {\n                var table = state_1.default().table;\n                var theme = config_1.getTheme(table.settings.theme);\n                var otherStyles = [theme.table, theme[sectionName], table.styles.styles, table.styles[sectionName + \"Styles\"]];\n                var columnStyles = table.styles.columnStyles[column.dataKey] || table.styles.columnStyles[column.index] || {};\n                var colStyles = sectionName === 'body' ? columnStyles : {};\n                var rowStyles = sectionName === 'body' && rowIndex % 2 === 0 ? polyfills_1.assign({}, theme.alternateRow, table.styles.alternateRowStyles) : {};\n                return polyfills_1.assign.apply(void 0, __spreadArrays([config_1.defaultStyles()], __spreadArrays(otherStyles, [rowStyles, colStyles])));\n            }\n            /***/ \n        }),\n        /* 13 */\n        /***/ (function (module, exports, __webpack_require__) {\n            \"use strict\";\n            Object.defineProperty(exports, \"__esModule\", { value: true });\n            // Limitations\n            // - No support for border spacing\n            // - No support for transparency\n            var common_1 = __webpack_require__(1);\n            var state_1 = __webpack_require__(0);\n            function parseCss(element, scaleFactor, ignored) {\n                if (ignored === void 0) {\n                    ignored = [];\n                }\n                var result = {};\n                var style = window.getComputedStyle(element);\n                function assign(name, value, accepted) {\n                    if (accepted === void 0) {\n                        accepted = [];\n                    }\n                    if ((accepted.length === 0 || accepted.indexOf(value) !== -1) && ignored.indexOf(name) === -1) {\n                        if (value === 0 || value) {\n                            result[name] = value;\n                        }\n                    }\n                }\n                var pxScaleFactor = 96 / 72;\n                assign('fillColor', parseColor(element, 'backgroundColor'));\n                assign('fontStyle', parseFontStyle(style));\n                assign('textColor', parseColor(element, 'color'));\n                assign('halign', style.textAlign, ['left', 'right', 'center', 'justify']);\n                assign('valign', style.verticalAlign, ['middle', 'bottom', 'top']);\n                assign('fontSize', parseInt(style.fontSize || '') / pxScaleFactor);\n                assign('cellPadding', parsePadding(style.padding, style.fontSize, style.lineHeight, scaleFactor));\n                // style.borderWidth only works in chrome (borderTopWidth etc works in firefox and ie as well)\n                assign('lineWidth', parseInt(style.borderTopWidth || '') / pxScaleFactor / scaleFactor);\n                assign('lineColor', parseColor(element, 'borderTopColor'));\n                var font = (style.fontFamily || '').toLowerCase();\n                if (state_1.default().doc.getFontList()[font]) {\n                    assign('font', font);\n                }\n                return result;\n            }\n            exports.parseCss = parseCss;\n            function parseFontStyle(style) {\n                var res = '';\n                if (style.fontWeight === 'bold' || style.fontWeight === 'bolder' || parseInt(style.fontWeight) >= 700) {\n                    res += 'bold';\n                }\n                if (style.fontStyle === 'italic' || style.fontStyle === 'oblique') {\n                    res += 'italic';\n                }\n                return res;\n            }\n            function parseColor(element, colorProp) {\n                var cssColor = realColor(element, colorProp);\n                if (!cssColor)\n                    return null;\n                var rgba = cssColor.match(/^rgba?\\((\\d+),\\s*(\\d+),\\s*(\\d+)(?:,\\s*(\\d*\\.?\\d*))?\\)$/);\n                if (!rgba || !Array.isArray(rgba)) {\n                    return null;\n                }\n                var color = [parseInt(rgba[1]), parseInt(rgba[2]), parseInt(rgba[3])];\n                var alpha = parseInt(rgba[4]);\n                if (alpha === 0 || isNaN(color[0]) || isNaN(color[1]) || isNaN(color[2])) {\n                    return null;\n                }\n                return color;\n            }\n            function realColor(elem, colorProp) {\n                if (!elem)\n                    return null;\n                var bg = window.getComputedStyle(elem)[colorProp];\n                if (bg === 'rgba(0, 0, 0, 0)' || bg === 'transparent' || bg === 'initial' || bg === 'inherit') {\n                    return realColor(elem.parentElement, colorProp);\n                }\n                else {\n                    return bg;\n                }\n            }\n            function parsePadding(val, fontSize, lineHeight, scaleFactor) {\n                if (!val)\n                    return null;\n                var pxScaleFactor = (96 / (72 / scaleFactor));\n                var linePadding = (parseInt(lineHeight) - parseInt(fontSize)) / scaleFactor / 2;\n                var padding = val.split(' ').map(function (n) {\n                    return parseInt(n) / pxScaleFactor;\n                });\n                padding = common_1.marginOrPadding(padding, 0);\n                if (linePadding > padding.top) {\n                    padding.top = linePadding;\n                }\n                if (linePadding > padding.bottom) {\n                    padding.bottom = linePadding;\n                }\n                return padding;\n            }\n            /***/ \n        }),\n        /* 14 */\n        /***/ (function (module, exports, __webpack_require__) {\n            \"use strict\";\n            Object.defineProperty(exports, \"__esModule\", { value: true });\n            var common_1 = __webpack_require__(1);\n            function default_1(allOptions) {\n                var _loop_1 = function (settings) {\n                    if (settings && typeof settings !== 'object') {\n                        console.error(\"The options parameter should be of type object, is: \" + typeof settings);\n                    }\n                    if (typeof settings.extendWidth !== 'undefined') {\n                        settings.tableWidth = settings.extendWidth ? 'auto' : 'wrap';\n                        console.error(\"Use of deprecated option: extendWidth, use tableWidth instead.\");\n                    }\n                    if (typeof settings.margins !== 'undefined') {\n                        if (typeof settings.margin === 'undefined')\n                            settings.margin = settings.margins;\n                        console.error(\"Use of deprecated option: margins, use margin instead.\");\n                    }\n                    if (settings.startY && typeof settings.startY !== 'number') {\n                        console.error('Invalid value for startY option', settings.startY);\n                        delete settings.startY;\n                    }\n                    if (!settings.didDrawPage && (settings.afterPageContent || settings.beforePageContent || settings.afterPageAdd)) {\n                        console.error(\"The afterPageContent, beforePageContent and afterPageAdd hooks are deprecated. Use didDrawPage instead\");\n                        settings.didDrawPage = function (data) {\n                            common_1.applyUserStyles();\n                            if (settings.beforePageContent)\n                                settings.beforePageContent(data);\n                            common_1.applyUserStyles();\n                            if (settings.afterPageContent)\n                                settings.afterPageContent(data);\n                            common_1.applyUserStyles();\n                            if (settings.afterPageAdd && data.pageNumber > 1) {\n                                data.afterPageAdd(data);\n                            }\n                            common_1.applyUserStyles();\n                        };\n                    }\n                    [\"createdHeaderCell\", \"drawHeaderRow\", \"drawRow\", \"drawHeaderCell\"].forEach(function (name) {\n                        if (settings[name]) {\n                            console.error(\"The \\\"\" + name + \"\\\" hook has changed in version 3.0, check the changelog for how to migrate.\");\n                        }\n                    });\n                    [['showFoot', 'showFooter'], ['showHead', 'showHeader'], ['didDrawPage', 'addPageContent'], ['didParseCell', 'createdCell'], ['headStyles', 'headerStyles']].forEach(function (_a) {\n                        var current = _a[0], deprecated = _a[1];\n                        if (settings[deprecated]) {\n                            console.error(\"Use of deprecated option \" + deprecated + \". Use \" + current + \" instead\");\n                            settings[current] = settings[deprecated];\n                        }\n                    });\n                    [['padding', 'cellPadding'], ['lineHeight', 'rowHeight'], 'fontSize', 'overflow'].forEach(function (o) {\n                        var deprecatedOption = typeof o === 'string' ? o : o[0];\n                        var style = typeof o === 'string' ? o : o[1];\n                        if (typeof settings[deprecatedOption] !== 'undefined') {\n                            if (typeof settings.styles[style] === 'undefined') {\n                                settings.styles[style] = settings[deprecatedOption];\n                            }\n                            console.error(\"Use of deprecated option: \" + deprecatedOption + \", use the style \" + style + \" instead.\");\n                        }\n                    });\n                    for (var _i = 0, _a = ['styles', 'bodyStyles', 'headStyles', 'footStyles']; _i < _a.length; _i++) {\n                        var styleProp = _a[_i];\n                        checkStyles(settings[styleProp] || {});\n                    }\n                    var columnStyles = settings['columnStyles'] || {};\n                    for (var _b = 0, _c = Object.keys(columnStyles); _b < _c.length; _b++) {\n                        var key = _c[_b];\n                        checkStyles(columnStyles[key] || {});\n                    }\n                };\n                for (var _i = 0, allOptions_1 = allOptions; _i < allOptions_1.length; _i++) {\n                    var settings = allOptions_1[_i];\n                    _loop_1(settings);\n                }\n            }\n            exports.default = default_1;\n            function checkStyles(styles) {\n                if (styles.rowHeight) {\n                    console.error(\"Use of deprecated style rowHeight. It is renamed to minCellHeight.\");\n                    if (!styles.minCellHeight) {\n                        styles.minCellHeight = styles.rowHeight;\n                    }\n                }\n                else if (styles.columnWidth) {\n                    console.error(\"Use of deprecated style columnWidth. It is renamed to cellWidth.\");\n                    if (!styles.cellWidth) {\n                        styles.cellWidth = styles.columnWidth;\n                    }\n                }\n            }\n            /***/ \n        }),\n        /* 15 */\n        /***/ (function (module, exports, __webpack_require__) {\n            var jsPDF = __webpack_require__(7);\n            /**\n             * Improved text function with halign and valign support\n             * Inspiration from: http://stackoverflow.com/questions/28327510/align-text-right-using-jspdf/28433113#28433113\n             */\n            jsPDF.API.autoTableText = function (text, x, y, styles) {\n                styles = styles || {};\n                var FONT_ROW_RATIO = 1.15;\n                if (typeof x !== 'number' || typeof y !== 'number') {\n                    console.error('The x and y parameters are required. Missing for text: ', text);\n                }\n                var k = this.internal.scaleFactor;\n                var fontSize = this.internal.getFontSize() / k;\n                var splitRegex = /\\r\\n|\\r|\\n/g;\n                var splitText = null;\n                var lineCount = 1;\n                if (styles.valign === 'middle' || styles.valign === 'bottom' || styles.halign === 'center' || styles.halign === 'right') {\n                    splitText = typeof text === 'string' ? text.split(splitRegex) : text;\n                    lineCount = splitText.length || 1;\n                }\n                // Align the top\n                y += fontSize * (2 - FONT_ROW_RATIO);\n                if (styles.valign === 'middle')\n                    y -= (lineCount / 2) * fontSize * FONT_ROW_RATIO;\n                else if (styles.valign === 'bottom')\n                    y -= lineCount * fontSize * FONT_ROW_RATIO;\n                if (styles.halign === 'center' || styles.halign === 'right') {\n                    var alignSize = fontSize;\n                    if (styles.halign === 'center')\n                        alignSize *= 0.5;\n                    if (lineCount >= 1) {\n                        for (var iLine = 0; iLine < splitText.length; iLine++) {\n                            this.text(splitText[iLine], x - this.getStringUnitWidth(splitText[iLine]) * alignSize, y);\n                            y += fontSize * FONT_ROW_RATIO;\n                        }\n                        return this;\n                    }\n                    x -= this.getStringUnitWidth(text) * alignSize;\n                }\n                if (styles.halign === 'justify') {\n                    this.text(text, x, y, { maxWidth: styles.maxWidth || 100, align: 'justify' });\n                }\n                else {\n                    this.text(text, x, y);\n                }\n                return this;\n            };\n            /***/ \n        })\n        /******/ \n    ]);\n});\n",null]}