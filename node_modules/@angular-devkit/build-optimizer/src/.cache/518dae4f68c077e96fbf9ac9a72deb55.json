{"remainingRequest":"/home/vishwvir/company_projects/tata/web/ui_propensity/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js??ref--8-1!/home/vishwvir/company_projects/tata/web/ui_propensity/node_modules/ng5-slider/esm5/ng5-slider.js","dependencies":[{"path":"/home/vishwvir/company_projects/tata/web/ui_propensity/node_modules/ng5-slider/esm5/ng5-slider.js","mtime":1596454950000},{"path":"/home/vishwvir/company_projects/tata/web/ui_propensity/node_modules/cache-loader/dist/cjs.js","mtime":1596454942000},{"path":"/home/vishwvir/company_projects/tata/web/ui_propensity/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js","mtime":1596454940000}],"contextDependencies":[],"result":["import { __values, __extends } from 'tslib';\nimport { Subject } from 'rxjs/Subject';\nimport 'rxjs/Subscription';\nimport { Renderer2, Directive, ElementRef, HostBinding, Component, ViewChild, HostListener, Input, EventEmitter, Output, ContentChild, ChangeDetectorRef, forwardRef, NgZone, NgModule } from '@angular/core';\nimport { throttleTime, tap, distinctUntilChanged, filter } from 'rxjs/operators';\nimport detectPassiveEvents from 'detect-passive-events';\nimport { NG_VALUE_ACCESSOR } from '@angular/forms';\nimport { CommonModule } from '@angular/common';\nvar PointerType = /*@__PURE__*/ (function () {\n    var PointerType = {\n        Min: 0,\n        Max: 1,\n    };\n    PointerType[PointerType.Min] = \"Min\";\n    PointerType[PointerType.Max] = \"Max\";\n    return PointerType;\n}());\nvar LabelType = /*@__PURE__*/ (function () {\n    var LabelType = {\n        Low: 0,\n        High: 1,\n        Floor: 2,\n        Ceil: 3,\n        TickValue: 4,\n    };\n    LabelType[LabelType.Low] = \"Low\";\n    LabelType[LabelType.High] = \"High\";\n    LabelType[LabelType.Floor] = \"Floor\";\n    LabelType[LabelType.Ceil] = \"Ceil\";\n    LabelType[LabelType.TickValue] = \"TickValue\";\n    return LabelType;\n}());\nvar Options = /** @class */ /*@__PURE__*/ (function () {\n    function Options() {\n        this.floor = 0;\n        this.ceil = null;\n        this.step = 1;\n        this.minRange = null;\n        this.maxRange = null;\n        this.pushRange = false;\n        this.minLimit = null;\n        this.maxLimit = null;\n        this.translate = null;\n        this.combineLabels = null;\n        this.getLegend = null;\n        this.stepsArray = null;\n        this.bindIndexForStepsArray = false;\n        this.draggableRange = false;\n        this.draggableRangeOnly = false;\n        this.showSelectionBar = false;\n        this.showSelectionBarEnd = false;\n        this.showSelectionBarFromValue = null;\n        this.showOuterSelectionBars = false;\n        this.hidePointerLabels = false;\n        this.hideLimitLabels = false;\n        this.autoHideLimitLabels = true;\n        this.readOnly = false;\n        this.disabled = false;\n        this.mouseEventsInterval = 50;\n        this.touchEventsInterval = 50;\n        this.inputEventsInterval = 100;\n        this.outputEventsInterval = 100;\n        this.showTicks = false;\n        this.showTicksValues = false;\n        this.tickStep = null;\n        this.tickValueStep = 1;\n        this.ticksArray = null;\n        this.ticksTooltip = null;\n        this.ticksValuesTooltip = null;\n        this.vertical = false;\n        this.getSelectionBarColor = null;\n        this.getTickColor = null;\n        this.getPointerColor = null;\n        this.keyboardSupport = true;\n        this.scale = 1;\n        this.enforceStep = true;\n        this.enforceRange = true;\n        this.noSwitching = false;\n        this.onlyBindHandles = false;\n        this.rightToLeft = false;\n        this.reversedControls = false;\n        this.boundPointerLabels = true;\n        this.logScale = false;\n        this.customValueToPosition = null;\n        this.customPositionToValue = null;\n        this.precisionLimit = 12;\n        this.selectionBarGradient = null;\n        this.ariaLabel = null;\n        this.ariaLabelledBy = null;\n        this.ariaLabelHigh = null;\n        this.ariaLabelledByHigh = null;\n        this.handleDimension = null;\n        this.barDimension = null;\n        this.animate = true;\n    }\n    return Options;\n}());\nvar ChangeContext = /** @class */ /*@__PURE__*/ (function () {\n    function ChangeContext() {\n    }\n    return ChangeContext;\n}());\nvar ValueHelper = /** @class */ /*@__PURE__*/ (function () {\n    function ValueHelper() {\n    }\n    ValueHelper.isNullOrUndefined = function (value) {\n        return value === undefined || value === null;\n    };\n    ValueHelper.linearValueToPosition = function (val, minVal, maxVal) {\n        var range = maxVal - minVal;\n        return (val - minVal) / range;\n    };\n    ValueHelper.logValueToPosition = function (val, minVal, maxVal) {\n        val = Math.log(val);\n        minVal = Math.log(minVal);\n        maxVal = Math.log(maxVal);\n        var range = maxVal - minVal;\n        return (val - minVal) / range;\n    };\n    ValueHelper.linearPositionToValue = function (percent, minVal, maxVal) {\n        return percent * (maxVal - minVal) + minVal;\n    };\n    ValueHelper.logPositionToValue = function (percent, minVal, maxVal) {\n        minVal = Math.log(minVal);\n        maxVal = Math.log(maxVal);\n        var value = percent * (maxVal - minVal) + minVal;\n        return Math.exp(value);\n    };\n    ValueHelper.findStepIndex = function (modelValue, stepsArray) {\n        var differences = stepsArray.map(function (step) { return Math.abs(modelValue - step.value); });\n        var minDifferenceIndex = 0;\n        for (var index = 0; index < stepsArray.length; index++) {\n            if (differences[index] !== differences[minDifferenceIndex] && differences[index] < differences[minDifferenceIndex]) {\n                minDifferenceIndex = index;\n            }\n        }\n        return minDifferenceIndex;\n    };\n    return ValueHelper;\n}());\nvar CompatibilityHelper = /** @class */ /*@__PURE__*/ (function () {\n    function CompatibilityHelper() {\n    }\n    CompatibilityHelper.isTouchEvent = function (event) {\n        if (((window)).TouchEvent !== undefined) {\n            return event instanceof TouchEvent;\n        }\n        return event.touches !== undefined;\n    };\n    CompatibilityHelper.isResizeObserverAvailable = function () {\n        return ((window)).ResizeObserver !== undefined;\n    };\n    return CompatibilityHelper;\n}());\nvar MathHelper = /** @class */ /*@__PURE__*/ (function () {\n    function MathHelper() {\n    }\n    MathHelper.roundToPrecisionLimit = function (value, precisionLimit) {\n        return +(value.toPrecision(precisionLimit));\n    };\n    MathHelper.clampToRange = function (value, floor, ceil) {\n        return Math.min(Math.max(value, floor), ceil);\n    };\n    return MathHelper;\n}());\nvar EventListener = /** @class */ /*@__PURE__*/ (function () {\n    function EventListener() {\n        this.eventName = null;\n        this.events = null;\n        this.eventsSubscription = null;\n        this.teardownCallback = null;\n    }\n    return EventListener;\n}());\nvar EventListenerHelper = /** @class */ /*@__PURE__*/ (function () {\n    function EventListenerHelper(renderer) {\n        this.renderer = renderer;\n    }\n    EventListenerHelper.prototype.attachPassiveEventListener = function (nativeElement, eventName, callback, throttleInterval) {\n        if (detectPassiveEvents.hasSupport !== true) {\n            return this.attachEventListener(nativeElement, eventName, callback, throttleInterval);\n        }\n        var listener = new EventListener();\n        listener.eventName = eventName;\n        listener.events = new Subject();\n        var observerCallback = function (event) {\n            listener.events.next(event);\n        };\n        nativeElement.addEventListener(eventName, observerCallback, { passive: true, capture: false });\n        listener.teardownCallback = function () {\n            nativeElement.removeEventListener(eventName, observerCallback, { passive: true, capture: false });\n        };\n        listener.eventsSubscription = listener.events\n            .pipe((!ValueHelper.isNullOrUndefined(throttleInterval))\n            ? throttleTime(throttleInterval, undefined, { leading: true, trailing: true })\n            : tap(function () { }))\n            .subscribe(function (event) {\n            callback(event);\n        });\n        return listener;\n    };\n    EventListenerHelper.prototype.detachEventListener = function (eventListener) {\n        if (!ValueHelper.isNullOrUndefined(eventListener.eventsSubscription)) {\n            eventListener.eventsSubscription.unsubscribe();\n            eventListener.eventsSubscription = null;\n        }\n        if (!ValueHelper.isNullOrUndefined(eventListener.events)) {\n            eventListener.events.complete();\n            eventListener.events = null;\n        }\n        if (!ValueHelper.isNullOrUndefined(eventListener.teardownCallback)) {\n            eventListener.teardownCallback();\n            eventListener.teardownCallback = null;\n        }\n    };\n    EventListenerHelper.prototype.attachEventListener = function (nativeElement, eventName, callback, throttleInterval) {\n        var listener = new EventListener();\n        listener.eventName = eventName;\n        listener.events = new Subject();\n        var observerCallback = function (event) {\n            listener.events.next(event);\n        };\n        listener.teardownCallback = this.renderer.listen(nativeElement, eventName, observerCallback);\n        listener.eventsSubscription = listener.events\n            .pipe((!ValueHelper.isNullOrUndefined(throttleInterval))\n            ? throttleTime(throttleInterval, undefined, { leading: true, trailing: true })\n            : tap(function () { }))\n            .subscribe(function (event) { callback(event); });\n        return listener;\n    };\n    return EventListenerHelper;\n}());\nvar SliderElementDirective = /** @class */ /*@__PURE__*/ (function () {\n    function SliderElementDirective(elemRef, renderer) {\n        this.elemRef = elemRef;\n        this.renderer = renderer;\n        this._position = 0;\n        this._dimension = 0;\n        this._alwaysHide = false;\n        this._vertical = false;\n        this._scale = 1;\n        this.opacity = 1;\n        this.visibility = 'visible';\n        this.left = '';\n        this.bottom = '';\n        this.height = '';\n        this.width = '';\n        this.eventListeners = [];\n        this.eventListenerHelper = new EventListenerHelper(this.renderer);\n    }\n    Object.defineProperty(SliderElementDirective.prototype, \"position\", {\n        get: function () {\n            return this._position;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SliderElementDirective.prototype, \"dimension\", {\n        get: function () {\n            return this._dimension;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SliderElementDirective.prototype, \"alwaysHide\", {\n        get: function () {\n            return this._alwaysHide;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SliderElementDirective.prototype, \"vertical\", {\n        get: function () {\n            return this._vertical;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SliderElementDirective.prototype, \"scale\", {\n        get: function () {\n            return this._scale;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    SliderElementDirective.prototype.setAlwaysHide = function (hide) {\n        this._alwaysHide = hide;\n        if (hide) {\n            this.visibility = 'hidden';\n        }\n        else {\n            this.visibility = 'visible';\n        }\n    };\n    SliderElementDirective.prototype.hide = function () {\n        this.opacity = 0;\n    };\n    SliderElementDirective.prototype.show = function () {\n        if (this.alwaysHide) {\n            return;\n        }\n        this.opacity = 1;\n    };\n    SliderElementDirective.prototype.isVisible = function () {\n        if (this.alwaysHide) {\n            return false;\n        }\n        return this.opacity !== 0;\n    };\n    SliderElementDirective.prototype.setVertical = function (vertical) {\n        this._vertical = vertical;\n        if (this._vertical) {\n            this.left = '';\n            this.width = '';\n        }\n        else {\n            this.bottom = '';\n            this.height = '';\n        }\n    };\n    SliderElementDirective.prototype.setScale = function (scale) {\n        this._scale = scale;\n    };\n    SliderElementDirective.prototype.setPosition = function (pos) {\n        this._position = pos;\n        if (this._vertical) {\n            this.bottom = Math.round(pos) + 'px';\n        }\n        else {\n            this.left = Math.round(pos) + 'px';\n        }\n    };\n    SliderElementDirective.prototype.calculateDimension = function () {\n        var val = this.getBoundingClientRect();\n        if (this.vertical) {\n            this._dimension = (val.bottom - val.top) * this.scale;\n        }\n        else {\n            this._dimension = (val.right - val.left) * this.scale;\n        }\n    };\n    SliderElementDirective.prototype.setDimension = function (dim) {\n        this._dimension = dim;\n        if (this._vertical) {\n            this.height = Math.round(dim) + 'px';\n        }\n        else {\n            this.width = Math.round(dim) + 'px';\n        }\n    };\n    SliderElementDirective.prototype.getBoundingClientRect = function () {\n        return this.elemRef.nativeElement.getBoundingClientRect();\n    };\n    SliderElementDirective.prototype.on = function (eventName, callback, debounceInterval) {\n        var listener = this.eventListenerHelper.attachEventListener(this.elemRef.nativeElement, eventName, callback, debounceInterval);\n        this.eventListeners.push(listener);\n    };\n    SliderElementDirective.prototype.onPassive = function (eventName, callback, debounceInterval) {\n        var listener = this.eventListenerHelper.attachPassiveEventListener(this.elemRef.nativeElement, eventName, callback, debounceInterval);\n        this.eventListeners.push(listener);\n    };\n    SliderElementDirective.prototype.off = function (eventName) {\n        var listenersToKeep;\n        var listenersToRemove;\n        if (!ValueHelper.isNullOrUndefined(eventName)) {\n            listenersToKeep = this.eventListeners.filter(function (event) { return event.eventName !== eventName; });\n            listenersToRemove = this.eventListeners.filter(function (event) { return event.eventName === eventName; });\n        }\n        else {\n            listenersToKeep = [];\n            listenersToRemove = this.eventListeners;\n        }\n        try {\n            for (var listenersToRemove_1 = __values(listenersToRemove), listenersToRemove_1_1 = listenersToRemove_1.next(); !listenersToRemove_1_1.done; listenersToRemove_1_1 = listenersToRemove_1.next()) {\n                var listener = listenersToRemove_1_1.value;\n                this.eventListenerHelper.detachEventListener(listener);\n            }\n        }\n        catch (e_1_1) {\n            e_1 = { error: e_1_1 };\n        }\n        finally {\n            try {\n                if (listenersToRemove_1_1 && !listenersToRemove_1_1.done && (_a = listenersToRemove_1.return))\n                    _a.call(listenersToRemove_1);\n            }\n            finally {\n                if (e_1)\n                    throw e_1.error;\n            }\n        }\n        this.eventListeners = listenersToKeep;\n        var e_1, _a;\n    };\n    return SliderElementDirective;\n}());\nvar SliderHandleDirective = /** @class */ /*@__PURE__*/ (function (_super) {\n    __extends(SliderHandleDirective, _super);\n    function SliderHandleDirective(elemRef, renderer) {\n        var _this = _super.call(this, elemRef, renderer) || this;\n        _this.active = false;\n        _this.role = '';\n        _this.tabindex = '';\n        _this.ariaOrientation = '';\n        _this.ariaLabel = '';\n        _this.ariaLabelledBy = '';\n        _this.ariaValueNow = '';\n        _this.ariaValueText = '';\n        _this.ariaValueMin = '';\n        _this.ariaValueMax = '';\n        return _this;\n    }\n    SliderHandleDirective.prototype.focus = function () {\n        this.elemRef.nativeElement.focus();\n    };\n    return SliderHandleDirective;\n}(SliderElementDirective));\nvar SliderLabelDirective = /** @class */ /*@__PURE__*/ (function (_super) {\n    __extends(SliderLabelDirective, _super);\n    function SliderLabelDirective(elemRef, renderer) {\n        var _this = _super.call(this, elemRef, renderer) || this;\n        _this._value = null;\n        return _this;\n    }\n    Object.defineProperty(SliderLabelDirective.prototype, \"value\", {\n        get: function () {\n            return this._value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    SliderLabelDirective.prototype.setValue = function (value) {\n        var recalculateDimension = false;\n        if (!this.alwaysHide &&\n            (ValueHelper.isNullOrUndefined(this.value) ||\n                this.value.length !== value.length ||\n                (this.value.length > 0 && this.dimension === 0))) {\n            recalculateDimension = true;\n        }\n        this._value = value;\n        this.elemRef.nativeElement.innerHTML = value;\n        if (recalculateDimension) {\n            this.calculateDimension();\n        }\n    };\n    return SliderLabelDirective;\n}(SliderElementDirective));\nvar Tick = /** @class */ /*@__PURE__*/ (function () {\n    function Tick() {\n        this.selected = false;\n        this.style = {};\n        this.tooltip = null;\n        this.tooltipPlacement = null;\n        this.value = null;\n        this.valueTooltip = null;\n        this.valueTooltipPlacement = null;\n        this.legend = null;\n    }\n    return Tick;\n}());\nvar Dragging = /** @class */ /*@__PURE__*/ (function () {\n    function Dragging() {\n        this.active = false;\n        this.value = 0;\n        this.difference = 0;\n        this.position = 0;\n        this.lowLimit = 0;\n        this.highLimit = 0;\n    }\n    return Dragging;\n}());\nvar ModelValues = /** @class */ /*@__PURE__*/ (function () {\n    function ModelValues() {\n    }\n    ModelValues.compare = function (x, y) {\n        if (ValueHelper.isNullOrUndefined(x) && ValueHelper.isNullOrUndefined(y)) {\n            return false;\n        }\n        if (ValueHelper.isNullOrUndefined(x) !== ValueHelper.isNullOrUndefined(y)) {\n            return false;\n        }\n        return x.value === y.value && x.highValue === y.highValue;\n    };\n    return ModelValues;\n}());\nvar ModelChange = /** @class */ /*@__PURE__*/ (function (_super) {\n    __extends(ModelChange, _super);\n    function ModelChange() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    ModelChange.compare = function (x, y) {\n        if (ValueHelper.isNullOrUndefined(x) && ValueHelper.isNullOrUndefined(y)) {\n            return false;\n        }\n        if (ValueHelper.isNullOrUndefined(x) !== ValueHelper.isNullOrUndefined(y)) {\n            return false;\n        }\n        return x.value === y.value &&\n            x.highValue === y.highValue &&\n            x.forceChange === y.forceChange;\n    };\n    return ModelChange;\n}(ModelValues));\nvar NG5_SLIDER_CONTROL_VALUE_ACCESSOR = {\n    provide: NG_VALUE_ACCESSOR,\n    useExisting: forwardRef(function () { return SliderComponent; }),\n    multi: true,\n};\nvar SliderComponent = /** @class */ /*@__PURE__*/ (function () {\n    function SliderComponent(renderer, elementRef, changeDetectionRef, zone) {\n        this.renderer = renderer;\n        this.elementRef = elementRef;\n        this.changeDetectionRef = changeDetectionRef;\n        this.zone = zone;\n        this.value = null;\n        this.valueChange = new EventEmitter();\n        this.highValue = null;\n        this.highValueChange = new EventEmitter();\n        this.options = new Options();\n        this.userChangeStart = new EventEmitter();\n        this.userChange = new EventEmitter();\n        this.userChangeEnd = new EventEmitter();\n        this.initHasRun = false;\n        this.inputModelChangeSubject = new Subject();\n        this.inputModelChangeSubscription = null;\n        this.outputModelChangeSubject = new Subject();\n        this.outputModelChangeSubscription = null;\n        this.viewLowValue = null;\n        this.viewHighValue = null;\n        this.viewOptions = new Options();\n        this.handleHalfDimension = 0;\n        this.maxHandlePosition = 0;\n        this.currentTrackingPointer = null;\n        this.currentFocusPointer = null;\n        this.firstKeyDown = false;\n        this.touchId = null;\n        this.dragging = new Dragging();\n        this.sliderElementVerticalClass = false;\n        this.sliderElementAnimateClass = false;\n        this.sliderElementDisabledAttr = null;\n        this.barStyle = {};\n        this.minPointerStyle = {};\n        this.maxPointerStyle = {};\n        this.fullBarTransparentClass = false;\n        this.selectionBarDraggableClass = false;\n        this.ticksUnderValuesClass = false;\n        this.intermediateTicks = false;\n        this.ticks = [];\n        this.eventListenerHelper = null;\n        this.onMoveEventListener = null;\n        this.onEndEventListener = null;\n        this.resizeObserver = null;\n        this.onTouchedCallback = null;\n        this.onChangeCallback = null;\n        this.eventListenerHelper = new EventListenerHelper(this.renderer);\n    }\n    Object.defineProperty(SliderComponent.prototype, \"manualRefresh\", {\n        set: function (manualRefresh) {\n            var _this = this;\n            this.unsubscribeManualRefresh();\n            this.manualRefreshSubscription = manualRefresh.subscribe(function () {\n                setTimeout(function () { return _this.calculateViewDimensionsAndDetectChanges(); });\n            });\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SliderComponent.prototype, \"triggerFocus\", {\n        set: function (triggerFocus) {\n            var _this = this;\n            this.unsubscribeTriggerFocus();\n            this.triggerFocusSubscription = triggerFocus.subscribe(function (pointerType) {\n                _this.focusPointer(pointerType);\n            });\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SliderComponent.prototype, \"range\", {\n        get: function () {\n            return !ValueHelper.isNullOrUndefined(this.value) && !ValueHelper.isNullOrUndefined(this.highValue);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SliderComponent.prototype, \"showTicks\", {\n        get: function () {\n            return this.viewOptions.showTicks;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    SliderComponent.prototype.ngOnInit = function () {\n        this.viewOptions = new Options();\n        Object.assign(this.viewOptions, this.options);\n        this.updateDisabledState();\n        this.updateVerticalState();\n    };\n    SliderComponent.prototype.ngAfterViewInit = function () {\n        this.applyOptions();\n        this.subscribeInputModelChangeSubject(this.viewOptions.inputEventsInterval);\n        this.subscribeOutputModelChangeSubject(this.viewOptions.outputEventsInterval);\n        this.renormaliseModelValues();\n        this.viewLowValue = this.modelValueToViewValue(this.value);\n        if (this.range) {\n            this.viewHighValue = this.modelValueToViewValue(this.highValue);\n        }\n        else {\n            this.viewHighValue = null;\n        }\n        this.updateVerticalState();\n        this.manageElementsStyle();\n        this.updateDisabledState();\n        this.calculateViewDimensions();\n        this.addAccessibility();\n        this.updateCeilLabel();\n        this.updateFloorLabel();\n        this.initHandles();\n        this.manageEventsBindings();\n        this.subscribeResizeObserver();\n        this.initHasRun = true;\n        this.changeDetectionRef.detectChanges();\n    };\n    SliderComponent.prototype.ngOnChanges = function (changes) {\n        if (!ValueHelper.isNullOrUndefined(changes[\"options\"])) {\n            this.onChangeOptions();\n        }\n        if (!ValueHelper.isNullOrUndefined(changes[\"value\"]) ||\n            !ValueHelper.isNullOrUndefined(changes[\"highValue\"])) {\n            this.inputModelChangeSubject.next({\n                value: this.value,\n                highValue: this.highValue,\n                forceChange: false,\n                internalChange: false\n            });\n        }\n    };\n    SliderComponent.prototype.ngOnDestroy = function () {\n        this.unbindEvents();\n        this.unsubscribeResizeObserver();\n        this.unsubscribeInputModelChangeSubject();\n        this.unsubscribeOutputModelChangeSubject();\n        this.unsubscribeManualRefresh();\n        this.unsubscribeTriggerFocus();\n    };\n    SliderComponent.prototype.writeValue = function (obj) {\n        if (obj instanceof Array) {\n            this.value = obj[0];\n            this.highValue = obj[1];\n        }\n        else {\n            this.value = obj;\n        }\n        this.inputModelChangeSubject.next({\n            value: this.value,\n            highValue: this.highValue,\n            forceChange: false,\n            internalChange: false\n        });\n    };\n    SliderComponent.prototype.registerOnChange = function (onChangeCallback) {\n        this.onChangeCallback = onChangeCallback;\n    };\n    SliderComponent.prototype.registerOnTouched = function (onTouchedCallback) {\n        this.onTouchedCallback = onTouchedCallback;\n    };\n    SliderComponent.prototype.setDisabledState = function (isDisabled) {\n        this.viewOptions.disabled = isDisabled;\n        this.updateDisabledState();\n    };\n    SliderComponent.prototype.onResize = function (event) {\n        this.calculateViewDimensionsAndDetectChanges();\n    };\n    SliderComponent.prototype.subscribeInputModelChangeSubject = function (interval) {\n        var _this = this;\n        this.inputModelChangeSubscription = this.inputModelChangeSubject\n            .pipe(distinctUntilChanged(ModelChange.compare), filter(function (modelChange) { return !modelChange.forceChange && !modelChange.internalChange; }), (!ValueHelper.isNullOrUndefined(interval))\n            ? throttleTime(interval, undefined, { leading: true, trailing: true })\n            : tap(function () { }))\n            .subscribe(function (modelChange) { return _this.applyInputModelChange(modelChange); });\n    };\n    SliderComponent.prototype.subscribeOutputModelChangeSubject = function (interval) {\n        var _this = this;\n        this.outputModelChangeSubscription = this.outputModelChangeSubject\n            .pipe(distinctUntilChanged(ModelChange.compare), (!ValueHelper.isNullOrUndefined(interval))\n            ? throttleTime(interval, undefined, { leading: true, trailing: true })\n            : tap(function () { }))\n            .subscribe(function (modelChange) { return _this.publishOutputModelChange(modelChange); });\n    };\n    SliderComponent.prototype.subscribeResizeObserver = function () {\n        var _this = this;\n        if (CompatibilityHelper.isResizeObserverAvailable()) {\n            this.resizeObserver = new ResizeObserver(function () { return _this.calculateViewDimensionsAndDetectChanges(); });\n            this.resizeObserver.observe(this.elementRef.nativeElement);\n        }\n    };\n    SliderComponent.prototype.unsubscribeResizeObserver = function () {\n        if (CompatibilityHelper.isResizeObserverAvailable() && this.resizeObserver !== null) {\n            this.resizeObserver.disconnect();\n            this.resizeObserver = null;\n        }\n    };\n    SliderComponent.prototype.unsubscribeOnMove = function () {\n        if (!ValueHelper.isNullOrUndefined(this.onMoveEventListener)) {\n            this.eventListenerHelper.detachEventListener(this.onMoveEventListener);\n            this.onMoveEventListener = null;\n        }\n    };\n    SliderComponent.prototype.unsubscribeOnEnd = function () {\n        if (!ValueHelper.isNullOrUndefined(this.onEndEventListener)) {\n            this.eventListenerHelper.detachEventListener(this.onEndEventListener);\n            this.onEndEventListener = null;\n        }\n    };\n    SliderComponent.prototype.unsubscribeInputModelChangeSubject = function () {\n        if (!ValueHelper.isNullOrUndefined(this.inputModelChangeSubscription)) {\n            this.inputModelChangeSubscription.unsubscribe();\n            this.inputModelChangeSubscription = null;\n        }\n    };\n    SliderComponent.prototype.unsubscribeOutputModelChangeSubject = function () {\n        if (!ValueHelper.isNullOrUndefined(this.outputModelChangeSubscription)) {\n            this.outputModelChangeSubscription.unsubscribe();\n            this.outputModelChangeSubscription = null;\n        }\n    };\n    SliderComponent.prototype.unsubscribeManualRefresh = function () {\n        if (!ValueHelper.isNullOrUndefined(this.manualRefreshSubscription)) {\n            this.manualRefreshSubscription.unsubscribe();\n            this.manualRefreshSubscription = null;\n        }\n    };\n    SliderComponent.prototype.unsubscribeTriggerFocus = function () {\n        if (!ValueHelper.isNullOrUndefined(this.triggerFocusSubscription)) {\n            this.triggerFocusSubscription.unsubscribe();\n            this.triggerFocusSubscription = null;\n        }\n    };\n    SliderComponent.prototype.getPointerElement = function (pointerType) {\n        if (pointerType === PointerType.Min) {\n            return this.minHandleElement;\n        }\n        else if (pointerType === PointerType.Max) {\n            return this.maxHandleElement;\n        }\n        return null;\n    };\n    SliderComponent.prototype.getCurrentTrackingValue = function () {\n        if (this.currentTrackingPointer === PointerType.Min) {\n            return this.viewLowValue;\n        }\n        else if (this.currentTrackingPointer === PointerType.Max) {\n            return this.viewHighValue;\n        }\n        return null;\n    };\n    SliderComponent.prototype.modelValueToViewValue = function (modelValue) {\n        if (ValueHelper.isNullOrUndefined(modelValue)) {\n            return NaN;\n        }\n        if (!ValueHelper.isNullOrUndefined(this.viewOptions.stepsArray) && !this.viewOptions.bindIndexForStepsArray) {\n            return ValueHelper.findStepIndex(+modelValue, this.viewOptions.stepsArray);\n        }\n        return +modelValue;\n    };\n    SliderComponent.prototype.viewValueToModelValue = function (viewValue) {\n        if (!ValueHelper.isNullOrUndefined(this.viewOptions.stepsArray) && !this.viewOptions.bindIndexForStepsArray) {\n            return this.getStepValue(viewValue);\n        }\n        return viewValue;\n    };\n    SliderComponent.prototype.getStepValue = function (sliderValue) {\n        var step = this.viewOptions.stepsArray[sliderValue];\n        return (!ValueHelper.isNullOrUndefined(step)) ? step.value : NaN;\n    };\n    SliderComponent.prototype.applyViewChange = function () {\n        this.value = this.viewValueToModelValue(this.viewLowValue);\n        if (this.range) {\n            this.highValue = this.viewValueToModelValue(this.viewHighValue);\n        }\n        this.outputModelChangeSubject.next({\n            value: this.value,\n            highValue: this.highValue,\n            userEventInitiated: true,\n            forceChange: false\n        });\n        this.inputModelChangeSubject.next({\n            value: this.value,\n            highValue: this.highValue,\n            forceChange: false,\n            internalChange: true\n        });\n    };\n    SliderComponent.prototype.applyInputModelChange = function (modelChange) {\n        var normalisedModelChange = this.normaliseModelValues(modelChange);\n        var normalisationChange = !ModelValues.compare(modelChange, normalisedModelChange);\n        if (normalisationChange) {\n            this.value = normalisedModelChange.value;\n            this.highValue = normalisedModelChange.highValue;\n        }\n        this.viewLowValue = this.modelValueToViewValue(normalisedModelChange.value);\n        if (this.range) {\n            this.viewHighValue = this.modelValueToViewValue(normalisedModelChange.highValue);\n        }\n        else {\n            this.viewHighValue = null;\n        }\n        this.updateLowHandle(this.valueToPosition(this.viewLowValue));\n        if (this.range) {\n            this.updateHighHandle(this.valueToPosition(this.viewHighValue));\n        }\n        this.updateSelectionBar();\n        this.updateTicksScale();\n        this.updateAriaAttributes();\n        if (this.range) {\n            this.updateCombinedLabel();\n        }\n        this.outputModelChangeSubject.next({\n            value: normalisedModelChange.value,\n            highValue: normalisedModelChange.highValue,\n            forceChange: normalisationChange,\n            userEventInitiated: false\n        });\n    };\n    SliderComponent.prototype.publishOutputModelChange = function (modelChange) {\n        var _this = this;\n        var emitOutputs = function () {\n            _this.valueChange.emit(modelChange.value);\n            if (_this.range) {\n                _this.highValueChange.emit(modelChange.highValue);\n            }\n            if (!ValueHelper.isNullOrUndefined(_this.onChangeCallback)) {\n                if (_this.range) {\n                    _this.onChangeCallback([modelChange.value, modelChange.highValue]);\n                }\n                else {\n                    _this.onChangeCallback(modelChange.value);\n                }\n            }\n            if (!ValueHelper.isNullOrUndefined(_this.onTouchedCallback)) {\n                if (_this.range) {\n                    _this.onTouchedCallback([modelChange.value, modelChange.highValue]);\n                }\n                else {\n                    _this.onTouchedCallback(modelChange.value);\n                }\n            }\n        };\n        if (modelChange.userEventInitiated) {\n            emitOutputs();\n            this.userChange.emit(this.getChangeContext());\n        }\n        else {\n            setTimeout(function () { emitOutputs(); });\n        }\n    };\n    SliderComponent.prototype.normaliseModelValues = function (input) {\n        var normalisedInput = new ModelValues();\n        normalisedInput.value = input.value;\n        normalisedInput.highValue = input.highValue;\n        if (this.viewOptions.enforceStep) {\n            normalisedInput.value = this.roundStep(normalisedInput.value);\n            if (this.range) {\n                normalisedInput.highValue = this.roundStep(normalisedInput.highValue);\n            }\n        }\n        if (!ValueHelper.isNullOrUndefined(this.viewOptions.stepsArray) || !this.viewOptions.enforceRange) {\n            return normalisedInput;\n        }\n        normalisedInput.value = MathHelper.clampToRange(normalisedInput.value, this.viewOptions.floor, this.viewOptions.ceil);\n        if (this.range) {\n            normalisedInput.highValue = MathHelper.clampToRange(normalisedInput.highValue, this.viewOptions.floor, this.viewOptions.ceil);\n        }\n        if (this.range && input.value > input.highValue) {\n            if (this.viewOptions.noSwitching) {\n                normalisedInput.value = normalisedInput.highValue;\n            }\n            else {\n                var tempValue = input.value;\n                normalisedInput.value = input.highValue;\n                normalisedInput.highValue = tempValue;\n            }\n        }\n        return normalisedInput;\n    };\n    SliderComponent.prototype.renormaliseModelValues = function () {\n        var previousModelValues = {\n            value: this.value,\n            highValue: this.highValue\n        };\n        var normalisedModelValues = this.normaliseModelValues(previousModelValues);\n        if (!ModelValues.compare(normalisedModelValues, previousModelValues)) {\n            this.value = normalisedModelValues.value;\n            this.highValue = normalisedModelValues.highValue;\n            this.outputModelChangeSubject.next({\n                value: this.value,\n                highValue: this.highValue,\n                forceChange: true,\n                userEventInitiated: false\n            });\n        }\n    };\n    SliderComponent.prototype.onChangeOptions = function () {\n        if (!this.initHasRun) {\n            return;\n        }\n        var previousInputEventsInterval = this.viewOptions.inputEventsInterval;\n        var previousOutputEventsInterval = this.viewOptions.outputEventsInterval;\n        this.applyOptions();\n        if (previousInputEventsInterval !== this.viewOptions.inputEventsInterval) {\n            this.unsubscribeInputModelChangeSubject();\n            this.subscribeInputModelChangeSubject(this.viewOptions.inputEventsInterval);\n        }\n        if (previousOutputEventsInterval !== this.viewOptions.outputEventsInterval) {\n            this.unsubscribeInputModelChangeSubject();\n            this.subscribeInputModelChangeSubject(this.viewOptions.outputEventsInterval);\n        }\n        this.renormaliseModelValues();\n        this.viewLowValue = this.modelValueToViewValue(this.value);\n        if (this.range) {\n            this.viewHighValue = this.modelValueToViewValue(this.highValue);\n        }\n        else {\n            this.viewHighValue = null;\n        }\n        this.resetSlider();\n    };\n    SliderComponent.prototype.applyOptions = function () {\n        this.viewOptions = new Options();\n        Object.assign(this.viewOptions, this.options);\n        this.viewOptions.draggableRange = this.range && this.viewOptions.draggableRange;\n        this.viewOptions.draggableRangeOnly = this.range && this.viewOptions.draggableRangeOnly;\n        if (this.viewOptions.draggableRangeOnly) {\n            this.viewOptions.draggableRange = true;\n        }\n        this.viewOptions.showTicks = this.viewOptions.showTicks ||\n            this.viewOptions.showTicksValues ||\n            !ValueHelper.isNullOrUndefined(this.viewOptions.ticksArray);\n        if (this.viewOptions.showTicks &&\n            (!ValueHelper.isNullOrUndefined(this.viewOptions.tickStep) || !ValueHelper.isNullOrUndefined(this.viewOptions.ticksArray))) {\n            this.intermediateTicks = true;\n        }\n        this.viewOptions.showSelectionBar = this.viewOptions.showSelectionBar ||\n            this.viewOptions.showSelectionBarEnd ||\n            !ValueHelper.isNullOrUndefined(this.viewOptions.showSelectionBarFromValue);\n        if (!ValueHelper.isNullOrUndefined(this.viewOptions.stepsArray)) {\n            this.applyStepsArrayOptions();\n        }\n        else {\n            this.applyFloorCeilOptions();\n        }\n        if (ValueHelper.isNullOrUndefined(this.viewOptions.combineLabels)) {\n            this.viewOptions.combineLabels = function (minValue, maxValue) {\n                return minValue + ' - ' + maxValue;\n            };\n        }\n        if (this.viewOptions.logScale && this.viewOptions.floor === 0) {\n            throw Error('Can\\'t use floor=0 with logarithmic scale');\n        }\n    };\n    SliderComponent.prototype.applyStepsArrayOptions = function () {\n        var _this = this;\n        this.viewOptions.floor = 0;\n        this.viewOptions.ceil = this.viewOptions.stepsArray.length - 1;\n        this.viewOptions.step = 1;\n        if (ValueHelper.isNullOrUndefined(this.viewOptions.translate)) {\n            this.viewOptions.translate = function (modelValue) {\n                if (_this.viewOptions.bindIndexForStepsArray) {\n                    return String(_this.getStepValue(modelValue));\n                }\n                return String(modelValue);\n            };\n        }\n        this.viewOptions.getLegend = function (index) {\n            var step = _this.viewOptions.stepsArray[index];\n            return step.legend;\n        };\n    };\n    SliderComponent.prototype.applyFloorCeilOptions = function () {\n        if (ValueHelper.isNullOrUndefined(this.viewOptions.step)) {\n            this.viewOptions.step = 1;\n        }\n        else {\n            this.viewOptions.step = +this.viewOptions.step;\n            if (this.viewOptions.step <= 0) {\n                this.viewOptions.step = 1;\n            }\n        }\n        if (ValueHelper.isNullOrUndefined(this.viewOptions.ceil) ||\n            ValueHelper.isNullOrUndefined(this.viewOptions.floor)) {\n            throw Error('floor and ceil options must be supplied');\n        }\n        this.viewOptions.ceil = +this.viewOptions.ceil;\n        this.viewOptions.floor = +this.viewOptions.floor;\n        if (ValueHelper.isNullOrUndefined(this.viewOptions.translate)) {\n            this.viewOptions.translate = function (value) { return String(value); };\n        }\n    };\n    SliderComponent.prototype.resetSlider = function () {\n        this.manageElementsStyle();\n        this.addAccessibility();\n        this.updateCeilLabel();\n        this.updateFloorLabel();\n        this.unbindEvents();\n        this.manageEventsBindings();\n        this.updateDisabledState();\n        this.calculateViewDimensions();\n        this.refocusPointerIfNeeded();\n    };\n    SliderComponent.prototype.focusPointer = function (pointerType) {\n        if (pointerType !== PointerType.Min && pointerType !== PointerType.Max) {\n            pointerType = PointerType.Min;\n        }\n        if (pointerType === PointerType.Min) {\n            this.minHandleElement.focus();\n        }\n        else if (this.range && pointerType === PointerType.Max) {\n            this.maxHandleElement.focus();\n        }\n    };\n    SliderComponent.prototype.refocusPointerIfNeeded = function () {\n        if (!ValueHelper.isNullOrUndefined(this.currentFocusPointer)) {\n            this.onPointerFocus(this.currentFocusPointer);\n            var element = this.getPointerElement(this.currentFocusPointer);\n            element.focus();\n        }\n    };\n    SliderComponent.prototype.manageElementsStyle = function () {\n        var _this = this;\n        this.updateScale();\n        this.floorLabelElement.setAlwaysHide(this.viewOptions.showTicksValues || this.viewOptions.hideLimitLabels);\n        this.ceilLabelElement.setAlwaysHide(this.viewOptions.showTicksValues || this.viewOptions.hideLimitLabels);\n        var hideLabelsForTicks = this.viewOptions.showTicksValues && !this.intermediateTicks;\n        this.minHandleLabelElement.setAlwaysHide(hideLabelsForTicks || this.viewOptions.hidePointerLabels);\n        this.maxHandleLabelElement.setAlwaysHide(hideLabelsForTicks || !this.range || this.viewOptions.hidePointerLabels);\n        this.combinedLabelElement.setAlwaysHide(hideLabelsForTicks || !this.range || this.viewOptions.hidePointerLabels);\n        this.selectionBarElement.setAlwaysHide(!this.range && !this.viewOptions.showSelectionBar);\n        this.leftOuterSelectionBarElement.setAlwaysHide(!this.range || !this.viewOptions.showOuterSelectionBars);\n        this.rightOuterSelectionBarElement.setAlwaysHide(!this.range || !this.viewOptions.showOuterSelectionBars);\n        this.fullBarTransparentClass = this.range && this.viewOptions.showOuterSelectionBars;\n        this.selectionBarDraggableClass = this.viewOptions.draggableRange && !this.viewOptions.onlyBindHandles;\n        this.ticksUnderValuesClass = this.intermediateTicks && this.options.showTicksValues;\n        if (this.sliderElementVerticalClass !== this.viewOptions.vertical) {\n            this.updateVerticalState();\n            setTimeout(function () { _this.resetSlider(); });\n        }\n        if (this.sliderElementAnimateClass !== this.viewOptions.animate) {\n            setTimeout(function () { _this.sliderElementAnimateClass = _this.viewOptions.animate; });\n        }\n    };\n    SliderComponent.prototype.manageEventsBindings = function () {\n        if (this.viewOptions.disabled || this.viewOptions.readOnly) {\n            this.unbindEvents();\n        }\n        else {\n            this.bindEvents();\n        }\n    };\n    SliderComponent.prototype.updateDisabledState = function () {\n        this.sliderElementDisabledAttr = this.viewOptions.disabled ? 'disabled' : null;\n    };\n    SliderComponent.prototype.updateVerticalState = function () {\n        this.sliderElementVerticalClass = this.viewOptions.vertical;\n        try {\n            for (var _a = __values(this.getAllSliderElements()), _b = _a.next(); !_b.done; _b = _a.next()) {\n                var element = _b.value;\n                if (!ValueHelper.isNullOrUndefined(element)) {\n                    element.setVertical(this.viewOptions.vertical);\n                }\n            }\n        }\n        catch (e_2_1) {\n            e_2 = { error: e_2_1 };\n        }\n        finally {\n            try {\n                if (_b && !_b.done && (_c = _a.return))\n                    _c.call(_a);\n            }\n            finally {\n                if (e_2)\n                    throw e_2.error;\n            }\n        }\n        var e_2, _c;\n    };\n    SliderComponent.prototype.updateScale = function () {\n        try {\n            for (var _a = __values(this.getAllSliderElements()), _b = _a.next(); !_b.done; _b = _a.next()) {\n                var element = _b.value;\n                element.setScale(this.viewOptions.scale);\n            }\n        }\n        catch (e_3_1) {\n            e_3 = { error: e_3_1 };\n        }\n        finally {\n            try {\n                if (_b && !_b.done && (_c = _a.return))\n                    _c.call(_a);\n            }\n            finally {\n                if (e_3)\n                    throw e_3.error;\n            }\n        }\n        var e_3, _c;\n    };\n    SliderComponent.prototype.getAllSliderElements = function () {\n        return [this.leftOuterSelectionBarElement,\n            this.rightOuterSelectionBarElement,\n            this.fullBarElement,\n            this.selectionBarElement,\n            this.minHandleElement,\n            this.maxHandleElement,\n            this.floorLabelElement,\n            this.ceilLabelElement,\n            this.minHandleLabelElement,\n            this.maxHandleLabelElement,\n            this.combinedLabelElement,\n            this.ticksElement\n        ];\n    };\n    SliderComponent.prototype.initHandles = function () {\n        this.updateLowHandle(this.valueToPosition(this.viewLowValue));\n        if (this.range) {\n            this.updateHighHandle(this.valueToPosition(this.viewHighValue));\n        }\n        this.updateSelectionBar();\n        if (this.range) {\n            this.updateCombinedLabel();\n        }\n        this.updateTicksScale();\n    };\n    SliderComponent.prototype.addAccessibility = function () {\n        this.updateAriaAttributes();\n        this.minHandleElement.role = 'slider';\n        if (this.viewOptions.keyboardSupport &&\n            !(this.viewOptions.readOnly || this.viewOptions.disabled)) {\n            this.minHandleElement.tabindex = '0';\n        }\n        else {\n            this.minHandleElement.tabindex = '';\n        }\n        if (this.viewOptions.vertical) {\n            this.minHandleElement.ariaOrientation = 'vertical';\n        }\n        if (!ValueHelper.isNullOrUndefined(this.viewOptions.ariaLabel)) {\n            this.minHandleElement.ariaLabel = this.viewOptions.ariaLabel;\n        }\n        else if (!ValueHelper.isNullOrUndefined(this.viewOptions.ariaLabelledBy)) {\n            this.minHandleElement.ariaLabelledBy = this.viewOptions.ariaLabelledBy;\n        }\n        if (this.range) {\n            this.maxHandleElement.role = 'slider';\n            if (this.viewOptions.keyboardSupport &&\n                !(this.viewOptions.readOnly || this.viewOptions.disabled)) {\n                this.maxHandleElement.tabindex = '0';\n            }\n            else {\n                this.maxHandleElement.tabindex = '';\n            }\n            this.maxHandleElement.ariaOrientation = this.viewOptions.vertical ? 'vertical' : 'horizontal';\n            if (!ValueHelper.isNullOrUndefined(this.viewOptions.ariaLabelHigh)) {\n                this.maxHandleElement.ariaLabel = this.viewOptions.ariaLabelHigh;\n            }\n            else if (!ValueHelper.isNullOrUndefined(this.viewOptions.ariaLabelledByHigh)) {\n                this.maxHandleElement.ariaLabelledBy = this.viewOptions.ariaLabelledByHigh;\n            }\n        }\n    };\n    SliderComponent.prototype.updateAriaAttributes = function () {\n        this.minHandleElement.ariaValueNow = (+this.value).toString();\n        this.minHandleElement.ariaValueText = this.viewOptions.translate(+this.value, LabelType.Low);\n        this.minHandleElement.ariaValueMin = this.viewOptions.floor.toString();\n        this.minHandleElement.ariaValueMax = this.viewOptions.ceil.toString();\n        if (this.range) {\n            this.maxHandleElement.ariaValueNow = (+this.highValue).toString();\n            this.maxHandleElement.ariaValueText = this.viewOptions.translate(+this.highValue, LabelType.High);\n            this.maxHandleElement.ariaValueMin = this.viewOptions.floor.toString();\n            this.maxHandleElement.ariaValueMax = this.viewOptions.ceil.toString();\n        }\n    };\n    SliderComponent.prototype.calculateViewDimensions = function () {\n        if (!ValueHelper.isNullOrUndefined(this.viewOptions.handleDimension)) {\n            this.minHandleElement.setDimension(this.viewOptions.handleDimension);\n        }\n        else {\n            this.minHandleElement.calculateDimension();\n        }\n        var handleWidth = this.minHandleElement.dimension;\n        this.handleHalfDimension = handleWidth / 2;\n        if (!ValueHelper.isNullOrUndefined(this.viewOptions.barDimension)) {\n            this.fullBarElement.setDimension(this.viewOptions.barDimension);\n        }\n        else {\n            this.fullBarElement.calculateDimension();\n        }\n        this.maxHandlePosition = this.fullBarElement.dimension - handleWidth;\n        if (this.initHasRun) {\n            this.updateFloorLabel();\n            this.updateCeilLabel();\n            this.initHandles();\n        }\n    };\n    SliderComponent.prototype.calculateViewDimensionsAndDetectChanges = function () {\n        this.calculateViewDimensions();\n        this.changeDetectionRef.detectChanges();\n    };\n    SliderComponent.prototype.updateTicksScale = function () {\n        var _this = this;\n        if (!this.viewOptions.showTicks) {\n            return;\n        }\n        var ticksArray = !ValueHelper.isNullOrUndefined(this.viewOptions.ticksArray)\n            ? this.viewOptions.ticksArray\n            : this.getTicksArray();\n        var translate = this.viewOptions.vertical ? 'translateY' : 'translateX';\n        if (this.viewOptions.rightToLeft) {\n            ticksArray.reverse();\n        }\n        var newTicks = ticksArray.map(function (value) {\n            var position = _this.valueToPosition(value);\n            if (_this.viewOptions.vertical) {\n                position = _this.maxHandlePosition - position;\n            }\n            var translation = translate + '(' + Math.round(position) + 'px)';\n            var tick = new Tick();\n            tick.selected = _this.isTickSelected(value);\n            tick.style = {\n                '-webkit-transform': translation,\n                '-moz-transform': translation,\n                '-o-transform': translation,\n                '-ms-transform': translation,\n                transform: translation,\n            };\n            if (tick.selected && !ValueHelper.isNullOrUndefined(_this.viewOptions.getSelectionBarColor)) {\n                tick.style['background-color'] = _this.getSelectionBarColor();\n            }\n            if (!tick.selected && !ValueHelper.isNullOrUndefined(_this.viewOptions.getTickColor)) {\n                tick.style['background-color'] = _this.getTickColor(value);\n            }\n            if (!ValueHelper.isNullOrUndefined(_this.viewOptions.ticksTooltip)) {\n                tick.tooltip = _this.viewOptions.ticksTooltip(value);\n                tick.tooltipPlacement = _this.viewOptions.vertical ? 'right' : 'top';\n            }\n            if (_this.viewOptions.showTicksValues && (value % _this.viewOptions.tickValueStep === 0)) {\n                tick.value = _this.getDisplayValue(value, LabelType.TickValue);\n                if (!ValueHelper.isNullOrUndefined(_this.viewOptions.ticksValuesTooltip)) {\n                    tick.valueTooltip = _this.viewOptions.ticksValuesTooltip(value);\n                    tick.valueTooltipPlacement = _this.viewOptions.vertical\n                        ? 'right'\n                        : 'top';\n                }\n            }\n            if (!ValueHelper.isNullOrUndefined(_this.viewOptions.getLegend)) {\n                var legend = _this.viewOptions.getLegend(value);\n                if (!ValueHelper.isNullOrUndefined(legend)) {\n                    tick.legend = legend;\n                }\n            }\n            return tick;\n        });\n        if (!ValueHelper.isNullOrUndefined(this.ticks) && this.ticks.length === newTicks.length) {\n            for (var i = 0; i < newTicks.length; ++i) {\n                Object.assign(this.ticks[i], newTicks[i]);\n            }\n        }\n        else {\n            this.ticks = newTicks;\n        }\n        this.changeDetectionRef.detectChanges();\n    };\n    SliderComponent.prototype.getTicksArray = function () {\n        var step = (!ValueHelper.isNullOrUndefined(this.viewOptions.tickStep)) ? this.viewOptions.tickStep : this.viewOptions.step;\n        var ticksArray = [];\n        for (var value = this.viewOptions.floor; value <= this.viewOptions.ceil; value += step) {\n            ticksArray.push(value);\n        }\n        return ticksArray;\n    };\n    SliderComponent.prototype.isTickSelected = function (value) {\n        if (!this.range) {\n            if (!ValueHelper.isNullOrUndefined(this.viewOptions.showSelectionBarFromValue)) {\n                var center = this.viewOptions.showSelectionBarFromValue;\n                if (this.viewLowValue > center &&\n                    value >= center &&\n                    value <= this.viewLowValue) {\n                    return true;\n                }\n                else if (this.viewLowValue < center &&\n                    value <= center &&\n                    value >= this.viewLowValue) {\n                    return true;\n                }\n            }\n            else if (this.viewOptions.showSelectionBarEnd) {\n                if (value >= this.viewLowValue) {\n                    return true;\n                }\n            }\n            else if (this.viewOptions.showSelectionBar && value <= this.viewLowValue) {\n                return true;\n            }\n        }\n        if (this.range && value >= this.viewLowValue && value <= this.viewHighValue) {\n            return true;\n        }\n        return false;\n    };\n    SliderComponent.prototype.updateFloorLabel = function () {\n        if (!this.floorLabelElement.alwaysHide) {\n            this.floorLabelElement.setValue(this.getDisplayValue(this.viewOptions.floor, LabelType.Floor));\n            this.floorLabelElement.calculateDimension();\n            var position = this.viewOptions.rightToLeft\n                ? this.fullBarElement.dimension - this.floorLabelElement.dimension\n                : 0;\n            this.floorLabelElement.setPosition(position);\n        }\n    };\n    SliderComponent.prototype.updateCeilLabel = function () {\n        if (!this.ceilLabelElement.alwaysHide) {\n            this.ceilLabelElement.setValue(this.getDisplayValue(this.viewOptions.ceil, LabelType.Ceil));\n            this.ceilLabelElement.calculateDimension();\n            var position = this.viewOptions.rightToLeft\n                ? 0\n                : this.fullBarElement.dimension - this.ceilLabelElement.dimension;\n            this.ceilLabelElement.setPosition(position);\n        }\n    };\n    SliderComponent.prototype.updateHandles = function (which, newPos) {\n        if (which === PointerType.Min) {\n            this.updateLowHandle(newPos);\n        }\n        else if (which === PointerType.Max) {\n            this.updateHighHandle(newPos);\n        }\n        this.updateSelectionBar();\n        this.updateTicksScale();\n        if (this.range) {\n            this.updateCombinedLabel();\n        }\n    };\n    SliderComponent.prototype.getHandleLabelPos = function (labelType, newPos) {\n        var labelDimension = (labelType === PointerType.Min)\n            ? this.minHandleLabelElement.dimension\n            : this.maxHandleLabelElement.dimension;\n        var nearHandlePos = newPos - labelDimension / 2 + this.handleHalfDimension;\n        var endOfBarPos = this.fullBarElement.dimension - labelDimension;\n        if (!this.viewOptions.boundPointerLabels) {\n            return nearHandlePos;\n        }\n        if ((this.viewOptions.rightToLeft && labelType === PointerType.Min) ||\n            (!this.viewOptions.rightToLeft && labelType === PointerType.Max)) {\n            return Math.min(nearHandlePos, endOfBarPos);\n        }\n        else {\n            return Math.min(Math.max(nearHandlePos, 0), endOfBarPos);\n        }\n    };\n    SliderComponent.prototype.updateLowHandle = function (newPos) {\n        this.minHandleElement.setPosition(newPos);\n        this.minHandleLabelElement.setValue(this.getDisplayValue(this.viewLowValue, LabelType.Low));\n        this.minHandleLabelElement.setPosition(this.getHandleLabelPos(PointerType.Min, newPos));\n        if (!ValueHelper.isNullOrUndefined(this.viewOptions.getPointerColor)) {\n            this.minPointerStyle = {\n                backgroundColor: this.getPointerColor(PointerType.Min),\n            };\n        }\n        if (this.viewOptions.autoHideLimitLabels) {\n            this.updateFloorAndCeilLabelsVisibility();\n        }\n    };\n    SliderComponent.prototype.updateHighHandle = function (newPos) {\n        this.maxHandleElement.setPosition(newPos);\n        this.maxHandleLabelElement.setValue(this.getDisplayValue(this.viewHighValue, LabelType.High));\n        this.maxHandleLabelElement.setPosition(this.getHandleLabelPos(PointerType.Max, newPos));\n        if (!ValueHelper.isNullOrUndefined(this.viewOptions.getPointerColor)) {\n            this.maxPointerStyle = {\n                backgroundColor: this.getPointerColor(PointerType.Max),\n            };\n        }\n        if (this.viewOptions.autoHideLimitLabels) {\n            this.updateFloorAndCeilLabelsVisibility();\n        }\n    };\n    SliderComponent.prototype.updateFloorAndCeilLabelsVisibility = function () {\n        if (this.viewOptions.hidePointerLabels) {\n            return;\n        }\n        var floorLabelHidden = false;\n        var ceilLabelHidden = false;\n        var isMinLabelAtFloor = this.isLabelBelowFloorLabel(this.minHandleLabelElement);\n        var isMinLabelAtCeil = this.isLabelAboveCeilLabel(this.minHandleLabelElement);\n        var isMaxLabelAtCeil = this.isLabelAboveCeilLabel(this.maxHandleLabelElement);\n        var isCombinedLabelAtFloor = this.isLabelBelowFloorLabel(this.combinedLabelElement);\n        var isCombinedLabelAtCeil = this.isLabelAboveCeilLabel(this.combinedLabelElement);\n        if (isMinLabelAtFloor) {\n            floorLabelHidden = true;\n            this.floorLabelElement.hide();\n        }\n        else {\n            floorLabelHidden = false;\n            this.floorLabelElement.show();\n        }\n        if (isMinLabelAtCeil) {\n            ceilLabelHidden = true;\n            this.ceilLabelElement.hide();\n        }\n        else {\n            ceilLabelHidden = false;\n            this.ceilLabelElement.show();\n        }\n        if (this.range) {\n            var hideCeil = this.combinedLabelElement.isVisible() ? isCombinedLabelAtCeil : isMaxLabelAtCeil;\n            var hideFloor = this.combinedLabelElement.isVisible() ? isCombinedLabelAtFloor : isMinLabelAtFloor;\n            if (hideCeil) {\n                this.ceilLabelElement.hide();\n            }\n            else if (!ceilLabelHidden) {\n                this.ceilLabelElement.show();\n            }\n            if (hideFloor) {\n                this.floorLabelElement.hide();\n            }\n            else if (!floorLabelHidden) {\n                this.floorLabelElement.show();\n            }\n        }\n    };\n    SliderComponent.prototype.isLabelBelowFloorLabel = function (label) {\n        var pos = label.position;\n        var dim = label.dimension;\n        var floorPos = this.floorLabelElement.position;\n        var floorDim = this.floorLabelElement.dimension;\n        return this.viewOptions.rightToLeft\n            ? pos + dim >= floorPos - 2\n            : pos <= floorPos + floorDim + 2;\n    };\n    SliderComponent.prototype.isLabelAboveCeilLabel = function (label) {\n        var pos = label.position;\n        var dim = label.dimension;\n        var ceilPos = this.ceilLabelElement.position;\n        var ceilDim = this.ceilLabelElement.dimension;\n        return this.viewOptions.rightToLeft\n            ? pos <= ceilPos + ceilDim + 2\n            : pos + dim >= ceilPos - 2;\n    };\n    SliderComponent.prototype.updateSelectionBar = function () {\n        var position = 0;\n        var dimension = 0;\n        var isSelectionBarFromRight = this.viewOptions.rightToLeft\n            ? !this.viewOptions.showSelectionBarEnd\n            : this.viewOptions.showSelectionBarEnd;\n        var positionForRange = this.viewOptions.rightToLeft\n            ? this.maxHandleElement.position + this.handleHalfDimension\n            : this.minHandleElement.position + this.handleHalfDimension;\n        if (this.range) {\n            dimension = Math.abs(this.maxHandleElement.position - this.minHandleElement.position);\n            position = positionForRange;\n        }\n        else {\n            if (!ValueHelper.isNullOrUndefined(this.viewOptions.showSelectionBarFromValue)) {\n                var center = this.viewOptions.showSelectionBarFromValue;\n                var centerPosition = this.valueToPosition(center);\n                var isModelGreaterThanCenter = this.viewOptions.rightToLeft\n                    ? this.viewLowValue <= center\n                    : this.viewLowValue > center;\n                if (isModelGreaterThanCenter) {\n                    dimension = this.minHandleElement.position - centerPosition;\n                    position = centerPosition + this.handleHalfDimension;\n                }\n                else {\n                    dimension = centerPosition - this.minHandleElement.position;\n                    position = this.minHandleElement.position + this.handleHalfDimension;\n                }\n            }\n            else if (isSelectionBarFromRight) {\n                dimension = Math.ceil(Math.abs(this.maxHandlePosition - this.minHandleElement.position) + this.handleHalfDimension);\n                position = Math.floor(this.minHandleElement.position + this.handleHalfDimension);\n            }\n            else {\n                dimension = this.minHandleElement.position + this.handleHalfDimension;\n                position = 0;\n            }\n        }\n        this.selectionBarElement.setDimension(dimension);\n        this.selectionBarElement.setPosition(position);\n        if (this.range && this.viewOptions.showOuterSelectionBars) {\n            if (this.viewOptions.rightToLeft) {\n                this.rightOuterSelectionBarElement.setDimension(position);\n                this.rightOuterSelectionBarElement.setPosition(0);\n                this.fullBarElement.calculateDimension();\n                this.leftOuterSelectionBarElement.setDimension(this.fullBarElement.dimension - (position + dimension));\n                this.leftOuterSelectionBarElement.setPosition(position + dimension);\n            }\n            else {\n                this.leftOuterSelectionBarElement.setDimension(position);\n                this.leftOuterSelectionBarElement.setPosition(0);\n                this.fullBarElement.calculateDimension();\n                this.rightOuterSelectionBarElement.setDimension(this.fullBarElement.dimension - (position + dimension));\n                this.rightOuterSelectionBarElement.setPosition(position + dimension);\n            }\n        }\n        if (!ValueHelper.isNullOrUndefined(this.viewOptions.getSelectionBarColor)) {\n            var color = this.getSelectionBarColor();\n            this.barStyle = {\n                backgroundColor: color,\n            };\n        }\n        else if (!ValueHelper.isNullOrUndefined(this.viewOptions.selectionBarGradient)) {\n            var offset = (!ValueHelper.isNullOrUndefined(this.viewOptions.showSelectionBarFromValue))\n                ? this.valueToPosition(this.viewOptions.showSelectionBarFromValue)\n                : 0;\n            var reversed = (offset - position > 0 && !isSelectionBarFromRight) || (offset - position <= 0 && isSelectionBarFromRight);\n            var direction = this.viewOptions.vertical\n                ? reversed ? 'bottom' : 'top'\n                : reversed ? 'left' : 'right';\n            this.barStyle = {\n                backgroundImage: 'linear-gradient(to ' +\n                    direction +\n                    ', ' +\n                    this.viewOptions.selectionBarGradient.from +\n                    ' 0%,' +\n                    this.viewOptions.selectionBarGradient.to +\n                    ' 100%)',\n            };\n            if (this.viewOptions.vertical) {\n                this.barStyle.backgroundPosition =\n                    'center ' +\n                        (offset +\n                            dimension +\n                            position +\n                            (reversed ? -this.handleHalfDimension : 0)) +\n                        'px';\n                this.barStyle.backgroundSize =\n                    '100% ' + (this.fullBarElement.dimension - this.handleHalfDimension) + 'px';\n            }\n            else {\n                this.barStyle.backgroundPosition =\n                    offset -\n                        position +\n                        (reversed ? this.handleHalfDimension : 0) +\n                        'px center';\n                this.barStyle.backgroundSize =\n                    this.fullBarElement.dimension - this.handleHalfDimension + 'px 100%';\n            }\n        }\n    };\n    SliderComponent.prototype.getSelectionBarColor = function () {\n        if (this.range) {\n            return this.viewOptions.getSelectionBarColor(this.value, this.highValue);\n        }\n        return this.viewOptions.getSelectionBarColor(this.value);\n    };\n    SliderComponent.prototype.getPointerColor = function (pointerType) {\n        if (pointerType === PointerType.Max) {\n            return this.viewOptions.getPointerColor(this.highValue, pointerType);\n        }\n        return this.viewOptions.getPointerColor(this.value, pointerType);\n    };\n    SliderComponent.prototype.getTickColor = function (value) {\n        return this.viewOptions.getTickColor(value);\n    };\n    SliderComponent.prototype.updateCombinedLabel = function () {\n        var isLabelOverlap = null;\n        if (this.viewOptions.rightToLeft) {\n            isLabelOverlap =\n                this.minHandleLabelElement.position - this.minHandleLabelElement.dimension - 10 <= this.maxHandleLabelElement.position;\n        }\n        else {\n            isLabelOverlap =\n                this.minHandleLabelElement.position + this.minHandleLabelElement.dimension + 10 >= this.maxHandleLabelElement.position;\n        }\n        if (isLabelOverlap) {\n            var lowDisplayValue = this.getDisplayValue(this.viewLowValue, LabelType.Low);\n            var highDisplayValue = this.getDisplayValue(this.viewHighValue, LabelType.High);\n            var combinedLabelValue = this.viewOptions.rightToLeft\n                ? this.viewOptions.combineLabels(highDisplayValue, lowDisplayValue)\n                : this.viewOptions.combineLabels(lowDisplayValue, highDisplayValue);\n            this.combinedLabelElement.setValue(combinedLabelValue);\n            var pos = this.viewOptions.boundPointerLabels\n                ? Math.min(Math.max(this.selectionBarElement.position +\n                    this.selectionBarElement.dimension / 2 -\n                    this.combinedLabelElement.dimension / 2, 0), this.fullBarElement.dimension - this.combinedLabelElement.dimension)\n                : this.selectionBarElement.position + this.selectionBarElement.dimension / 2 - this.combinedLabelElement.dimension / 2;\n            this.combinedLabelElement.setPosition(pos);\n            this.minHandleLabelElement.hide();\n            this.maxHandleLabelElement.hide();\n            this.combinedLabelElement.show();\n        }\n        else {\n            this.updateHighHandle(this.valueToPosition(this.viewHighValue));\n            this.updateLowHandle(this.valueToPosition(this.viewLowValue));\n            this.maxHandleLabelElement.show();\n            this.minHandleLabelElement.show();\n            this.combinedLabelElement.hide();\n        }\n        if (this.viewOptions.autoHideLimitLabels) {\n            this.updateFloorAndCeilLabelsVisibility();\n        }\n    };\n    SliderComponent.prototype.getDisplayValue = function (value, which) {\n        if (!ValueHelper.isNullOrUndefined(this.viewOptions.stepsArray) && !this.viewOptions.bindIndexForStepsArray) {\n            value = this.getStepValue(value);\n        }\n        return this.viewOptions.translate(value, which);\n    };\n    SliderComponent.prototype.roundStep = function (value, customStep) {\n        var step = !ValueHelper.isNullOrUndefined(customStep) ? customStep : this.viewOptions.step;\n        var steppedDifference = MathHelper.roundToPrecisionLimit((value - this.viewOptions.floor) / step, this.viewOptions.precisionLimit);\n        steppedDifference = Math.round(steppedDifference) * step;\n        return MathHelper.roundToPrecisionLimit(this.viewOptions.floor + steppedDifference, this.viewOptions.precisionLimit);\n    };\n    SliderComponent.prototype.valueToPosition = function (val) {\n        var fn = ValueHelper.linearValueToPosition;\n        if (!ValueHelper.isNullOrUndefined(this.viewOptions.customValueToPosition)) {\n            fn = this.viewOptions.customValueToPosition;\n        }\n        else if (this.viewOptions.logScale) {\n            fn = ValueHelper.logValueToPosition;\n        }\n        val = MathHelper.clampToRange(val, this.viewOptions.floor, this.viewOptions.ceil);\n        var percent = fn(val, this.viewOptions.floor, this.viewOptions.ceil);\n        if (ValueHelper.isNullOrUndefined(percent)) {\n            percent = 0;\n        }\n        if (this.viewOptions.rightToLeft) {\n            percent = 1 - percent;\n        }\n        return percent * this.maxHandlePosition;\n    };\n    SliderComponent.prototype.positionToValue = function (position) {\n        var percent = position / this.maxHandlePosition;\n        if (this.viewOptions.rightToLeft) {\n            percent = 1 - percent;\n        }\n        var fn = ValueHelper.linearPositionToValue;\n        if (!ValueHelper.isNullOrUndefined(this.viewOptions.customPositionToValue)) {\n            fn = this.viewOptions.customPositionToValue;\n        }\n        else if (this.viewOptions.logScale) {\n            fn = ValueHelper.logPositionToValue;\n        }\n        var value = fn(percent, this.viewOptions.floor, this.viewOptions.ceil);\n        return !ValueHelper.isNullOrUndefined(value) ? value : 0;\n    };\n    SliderComponent.prototype.getEventXY = function (event, targetTouchId) {\n        if (event instanceof MouseEvent) {\n            return this.viewOptions.vertical ? event.clientY : event.clientX;\n        }\n        var touchIndex = 0;\n        var touches = event.touches;\n        if (!ValueHelper.isNullOrUndefined(targetTouchId)) {\n            for (var i = 0; i < touches.length; i++) {\n                if (touches[i].identifier === targetTouchId) {\n                    touchIndex = i;\n                    break;\n                }\n            }\n        }\n        return this.viewOptions.vertical ? touches[touchIndex].clientY : touches[touchIndex].clientX;\n    };\n    SliderComponent.prototype.getEventPosition = function (event, targetTouchId) {\n        var sliderElementBoundingRect = this.elementRef.nativeElement.getBoundingClientRect();\n        var sliderPos = this.viewOptions.vertical ?\n            sliderElementBoundingRect.bottom : sliderElementBoundingRect.left;\n        var eventPos = 0;\n        if (this.viewOptions.vertical) {\n            eventPos = -this.getEventXY(event, targetTouchId) + sliderPos;\n        }\n        else {\n            eventPos = this.getEventXY(event, targetTouchId) - sliderPos;\n        }\n        return eventPos * this.viewOptions.scale - this.handleHalfDimension;\n    };\n    SliderComponent.prototype.getNearestHandle = function (event) {\n        if (!this.range) {\n            return PointerType.Min;\n        }\n        var position = this.getEventPosition(event);\n        var distanceMin = Math.abs(position - this.minHandleElement.position);\n        var distanceMax = Math.abs(position - this.maxHandleElement.position);\n        if (distanceMin < distanceMax) {\n            return PointerType.Min;\n        }\n        else if (distanceMin > distanceMax) {\n            return PointerType.Max;\n        }\n        else if (!this.viewOptions.rightToLeft) {\n            return position < this.minHandleElement.position ? PointerType.Min : PointerType.Max;\n        }\n        return position > this.minHandleElement.position ? PointerType.Min : PointerType.Max;\n    };\n    SliderComponent.prototype.bindEvents = function () {\n        var _this = this;\n        var draggableRange = this.viewOptions.draggableRange;\n        if (!this.viewOptions.onlyBindHandles) {\n            this.selectionBarElement.on('mousedown', function (event) { return _this.onBarStart(null, draggableRange, event, true, true, true); });\n        }\n        if (this.viewOptions.draggableRangeOnly) {\n            this.minHandleElement.on('mousedown', function (event) { return _this.onBarStart(PointerType.Min, draggableRange, event, true, true); });\n            this.maxHandleElement.on('mousedown', function (event) { return _this.onBarStart(PointerType.Max, draggableRange, event, true, true); });\n        }\n        else {\n            this.minHandleElement.on('mousedown', function (event) { return _this.onStart(PointerType.Min, event, true, true); });\n            if (this.range) {\n                this.maxHandleElement.on('mousedown', function (event) { return _this.onStart(PointerType.Max, event, true, true); });\n            }\n            if (!this.viewOptions.onlyBindHandles) {\n                this.fullBarElement.on('mousedown', function (event) { return _this.onStart(null, event, true, true, true); });\n                this.ticksElement.on('mousedown', function (event) { return _this.onStart(null, event, true, true, true, true); });\n            }\n        }\n        if (!this.viewOptions.onlyBindHandles) {\n            this.selectionBarElement.onPassive('touchstart', function (event) { return _this.onBarStart(null, draggableRange, event, true, true, true); });\n        }\n        if (this.viewOptions.draggableRangeOnly) {\n            this.minHandleElement.onPassive('touchstart', function (event) { return _this.onBarStart(PointerType.Min, draggableRange, event, true, true); });\n            this.maxHandleElement.onPassive('touchstart', function (event) { return _this.onBarStart(PointerType.Max, draggableRange, event, true, true); });\n        }\n        else {\n            this.minHandleElement.onPassive('touchstart', function (event) { return _this.onStart(PointerType.Min, event, true, true); });\n            if (this.range) {\n                this.maxHandleElement.onPassive('touchstart', function (event) { return _this.onStart(PointerType.Max, event, true, true); });\n            }\n            if (!this.viewOptions.onlyBindHandles) {\n                this.fullBarElement.onPassive('touchstart', function (event) { return _this.onStart(null, event, true, true, true); });\n                this.ticksElement.onPassive('touchstart', function (event) { return _this.onStart(null, event, false, false, true, true); });\n            }\n        }\n        if (this.viewOptions.keyboardSupport) {\n            this.minHandleElement.on('focus', function () { return _this.onPointerFocus(PointerType.Min); });\n            if (this.range) {\n                this.maxHandleElement.on('focus', function () { return _this.onPointerFocus(PointerType.Max); });\n            }\n        }\n    };\n    SliderComponent.prototype.unbindEvents = function () {\n        this.unsubscribeOnMove();\n        this.unsubscribeOnEnd();\n        try {\n            for (var _a = __values(this.getAllSliderElements()), _b = _a.next(); !_b.done; _b = _a.next()) {\n                var element = _b.value;\n                element.off();\n            }\n        }\n        catch (e_4_1) {\n            e_4 = { error: e_4_1 };\n        }\n        finally {\n            try {\n                if (_b && !_b.done && (_c = _a.return))\n                    _c.call(_a);\n            }\n            finally {\n                if (e_4)\n                    throw e_4.error;\n            }\n        }\n        var e_4, _c;\n    };\n    SliderComponent.prototype.onBarStart = function (pointerType, draggableRange, event, bindMove, bindEnd, simulateImmediateMove, simulateImmediateEnd) {\n        if (draggableRange) {\n            this.onDragStart(pointerType, event, bindMove, bindEnd);\n        }\n        else {\n            this.onStart(pointerType, event, bindMove, bindEnd, simulateImmediateMove, simulateImmediateEnd);\n        }\n    };\n    SliderComponent.prototype.onStart = function (pointerType, event, bindMove, bindEnd, simulateImmediateMove, simulateImmediateEnd) {\n        var _this = this;\n        event.stopPropagation();\n        if (!CompatibilityHelper.isTouchEvent(event) || !detectPassiveEvents.hasSupport) {\n            event.preventDefault();\n        }\n        this.calculateViewDimensions();\n        if (ValueHelper.isNullOrUndefined(pointerType)) {\n            pointerType = this.getNearestHandle(event);\n        }\n        this.currentTrackingPointer = pointerType;\n        var pointerElement = this.getPointerElement(pointerType);\n        pointerElement.active = true;\n        if (this.viewOptions.keyboardSupport) {\n            pointerElement.focus();\n        }\n        if (bindMove) {\n            this.unsubscribeOnMove();\n            var onMoveCallback = function (e) { return _this.dragging.active ? _this.onDragMove(e) : _this.onMove(e); };\n            if (CompatibilityHelper.isTouchEvent(event)) {\n                this.onMoveEventListener = this.eventListenerHelper.attachPassiveEventListener(document, 'touchmove', onMoveCallback, this.viewOptions.touchEventsInterval);\n            }\n            else {\n                this.onMoveEventListener = this.eventListenerHelper.attachEventListener(document, 'mousemove', onMoveCallback, this.viewOptions.mouseEventsInterval);\n            }\n        }\n        if (bindEnd) {\n            this.unsubscribeOnEnd();\n            var onEndCallback = function (e) { return _this.onEnd(e); };\n            if (CompatibilityHelper.isTouchEvent(event)) {\n                this.onEndEventListener = this.eventListenerHelper.attachPassiveEventListener(document, 'touchend', onEndCallback);\n            }\n            else {\n                this.onEndEventListener = this.eventListenerHelper.attachEventListener(document, 'mouseup', onEndCallback);\n            }\n        }\n        this.userChangeStart.emit(this.getChangeContext());\n        if (CompatibilityHelper.isTouchEvent(event) && !ValueHelper.isNullOrUndefined(((event)).changedTouches)) {\n            if (ValueHelper.isNullOrUndefined(this.touchId)) {\n                this.touchId = ((event)).changedTouches[0].identifier;\n            }\n        }\n        if (simulateImmediateMove) {\n            this.onMove(event, true);\n        }\n        if (simulateImmediateEnd) {\n            this.onEnd(event);\n        }\n    };\n    SliderComponent.prototype.onMove = function (event, fromTick) {\n        var touchForThisSlider = null;\n        if (CompatibilityHelper.isTouchEvent(event)) {\n            var changedTouches = ((event)).changedTouches;\n            for (var i = 0; i < changedTouches.length; i++) {\n                if (changedTouches[i].identifier === this.touchId) {\n                    touchForThisSlider = changedTouches[i];\n                    break;\n                }\n            }\n            if (ValueHelper.isNullOrUndefined(touchForThisSlider)) {\n                return;\n            }\n        }\n        var newPos = !ValueHelper.isNullOrUndefined(touchForThisSlider)\n            ? this.getEventPosition(event, touchForThisSlider.identifier)\n            : this.getEventPosition(event);\n        var newValue;\n        var ceilValue = this.viewOptions.rightToLeft\n            ? this.viewOptions.floor\n            : this.viewOptions.ceil;\n        var floorValue = this.viewOptions.rightToLeft ? this.viewOptions.ceil : this.viewOptions.floor;\n        if (newPos <= 0) {\n            newValue = floorValue;\n        }\n        else if (newPos >= this.maxHandlePosition) {\n            newValue = ceilValue;\n        }\n        else {\n            newValue = this.positionToValue(newPos);\n            if (fromTick && !ValueHelper.isNullOrUndefined(this.viewOptions.tickStep)) {\n                newValue = this.roundStep(newValue, this.viewOptions.tickStep);\n            }\n            else {\n                newValue = this.roundStep(newValue);\n            }\n        }\n        this.positionTrackingHandle(newValue);\n    };\n    SliderComponent.prototype.onEnd = function (event) {\n        if (CompatibilityHelper.isTouchEvent(event)) {\n            var changedTouches = ((event)).changedTouches;\n            if (changedTouches[0].identifier !== this.touchId) {\n                return;\n            }\n        }\n        this.touchId = null;\n        if (!this.viewOptions.keyboardSupport) {\n            this.minHandleElement.active = false;\n            this.maxHandleElement.active = false;\n            this.currentTrackingPointer = null;\n        }\n        this.dragging.active = false;\n        this.unsubscribeOnMove();\n        this.unsubscribeOnEnd();\n        this.userChangeEnd.emit(this.getChangeContext());\n    };\n    SliderComponent.prototype.onPointerFocus = function (pointerType) {\n        var _this = this;\n        var pointerElement = this.getPointerElement(pointerType);\n        pointerElement.on('blur', function () { return _this.onPointerBlur(pointerElement); });\n        pointerElement.on('keydown', function (event) { return _this.onKeyboardEvent(event); });\n        pointerElement.on('keyup', function () { return _this.onKeyUp(); });\n        pointerElement.active = true;\n        this.currentTrackingPointer = pointerType;\n        this.currentFocusPointer = pointerType;\n        this.firstKeyDown = true;\n    };\n    SliderComponent.prototype.onKeyUp = function () {\n        this.firstKeyDown = true;\n        this.userChangeEnd.emit(this.getChangeContext());\n    };\n    SliderComponent.prototype.onPointerBlur = function (pointer) {\n        pointer.off('blur');\n        pointer.off('keydown');\n        pointer.off('keyup');\n        pointer.active = false;\n        if (ValueHelper.isNullOrUndefined(this.touchId)) {\n            this.currentTrackingPointer = null;\n            this.currentFocusPointer = null;\n        }\n    };\n    SliderComponent.prototype.getKeyActions = function (currentValue) {\n        var valueRange = this.viewOptions.ceil - this.viewOptions.floor;\n        var increaseStep = currentValue + this.viewOptions.step;\n        var decreaseStep = currentValue - this.viewOptions.step;\n        var increasePage = currentValue + valueRange / 10;\n        var decreasePage = currentValue - valueRange / 10;\n        if (this.viewOptions.reversedControls) {\n            increaseStep = currentValue - this.viewOptions.step;\n            decreaseStep = currentValue + this.viewOptions.step;\n            increasePage = currentValue - valueRange / 10;\n            decreasePage = currentValue + valueRange / 10;\n        }\n        var actions = {\n            UP: increaseStep,\n            DOWN: decreaseStep,\n            LEFT: decreaseStep,\n            RIGHT: increaseStep,\n            PAGEUP: increasePage,\n            PAGEDOWN: decreasePage,\n            HOME: this.viewOptions.reversedControls ? this.viewOptions.ceil : this.viewOptions.floor,\n            END: this.viewOptions.reversedControls ? this.viewOptions.floor : this.viewOptions.ceil,\n        };\n        if (this.viewOptions.rightToLeft) {\n            actions[\"LEFT\"] = increaseStep;\n            actions[\"RIGHT\"] = decreaseStep;\n            if (this.viewOptions.vertical) {\n                actions[\"UP\"] = decreaseStep;\n                actions[\"DOWN\"] = increaseStep;\n            }\n        }\n        return actions;\n    };\n    SliderComponent.prototype.onKeyboardEvent = function (event) {\n        var currentValue = this.getCurrentTrackingValue();\n        var keyCode = !ValueHelper.isNullOrUndefined(event.keyCode)\n            ? event.keyCode\n            : event.which;\n        var keys = {\n            38: 'UP',\n            40: 'DOWN',\n            37: 'LEFT',\n            39: 'RIGHT',\n            33: 'PAGEUP',\n            34: 'PAGEDOWN',\n            36: 'HOME',\n            35: 'END',\n        };\n        var actions = this.getKeyActions(currentValue);\n        var key = keys[keyCode];\n        var action = actions[key];\n        if (ValueHelper.isNullOrUndefined(action) || ValueHelper.isNullOrUndefined(this.currentTrackingPointer)) {\n            return;\n        }\n        event.preventDefault();\n        if (this.firstKeyDown) {\n            this.firstKeyDown = false;\n            this.userChangeStart.emit(this.getChangeContext());\n        }\n        var actionValue = MathHelper.clampToRange(action, this.viewOptions.floor, this.viewOptions.ceil);\n        var newValue = this.roundStep(actionValue);\n        if (!this.viewOptions.draggableRangeOnly) {\n            this.positionTrackingHandle(newValue);\n        }\n        else {\n            var difference = this.viewHighValue - this.viewLowValue;\n            var newMinValue = void 0;\n            var newMaxValue = void 0;\n            if (this.currentTrackingPointer === PointerType.Min) {\n                newMinValue = newValue;\n                newMaxValue = newValue + difference;\n                if (newMaxValue > this.viewOptions.ceil) {\n                    newMaxValue = this.viewOptions.ceil;\n                    newMinValue = newMaxValue - difference;\n                }\n            }\n            else if (this.currentTrackingPointer === PointerType.Max) {\n                newMaxValue = newValue;\n                newMinValue = newValue - difference;\n                if (newMinValue < this.viewOptions.floor) {\n                    newMinValue = this.viewOptions.floor;\n                    newMaxValue = newMinValue + difference;\n                }\n            }\n            this.positionTrackingBar(newMinValue, newMaxValue);\n        }\n    };\n    SliderComponent.prototype.onDragStart = function (pointerType, event, bindMove, bindEnd) {\n        var position = this.getEventPosition(event);\n        this.dragging = new Dragging();\n        this.dragging.active = true;\n        this.dragging.value = this.positionToValue(position);\n        this.dragging.difference = this.viewHighValue - this.viewLowValue;\n        this.dragging.lowLimit = this.viewOptions.rightToLeft\n            ? this.minHandleElement.position - position\n            : position - this.minHandleElement.position;\n        this.dragging.highLimit = this.viewOptions.rightToLeft\n            ? position - this.maxHandleElement.position\n            : this.maxHandleElement.position - position;\n        this.onStart(pointerType, event, bindMove, bindEnd);\n    };\n    SliderComponent.prototype.getMinValue = function (newPos, outOfBounds, isAbove) {\n        var isRTL = this.viewOptions.rightToLeft;\n        var value = null;\n        if (outOfBounds) {\n            if (isAbove) {\n                value = isRTL\n                    ? this.viewOptions.floor\n                    : this.viewOptions.ceil - this.dragging.difference;\n            }\n            else {\n                value = isRTL\n                    ? this.viewOptions.ceil - this.dragging.difference\n                    : this.viewOptions.floor;\n            }\n        }\n        else {\n            value = isRTL\n                ? this.positionToValue(newPos + this.dragging.lowLimit)\n                : this.positionToValue(newPos - this.dragging.lowLimit);\n        }\n        return this.roundStep(value);\n    };\n    SliderComponent.prototype.getMaxValue = function (newPos, outOfBounds, isAbove) {\n        var isRTL = this.viewOptions.rightToLeft;\n        var value = null;\n        if (outOfBounds) {\n            if (isAbove) {\n                value = isRTL\n                    ? this.viewOptions.floor + this.dragging.difference\n                    : this.viewOptions.ceil;\n            }\n            else {\n                value = isRTL\n                    ? this.viewOptions.ceil\n                    : this.viewOptions.floor + this.dragging.difference;\n            }\n        }\n        else {\n            if (isRTL) {\n                value =\n                    this.positionToValue(newPos + this.dragging.lowLimit) +\n                        this.dragging.difference;\n            }\n            else {\n                value =\n                    this.positionToValue(newPos - this.dragging.lowLimit) +\n                        this.dragging.difference;\n            }\n        }\n        return this.roundStep(value);\n    };\n    SliderComponent.prototype.onDragMove = function (event) {\n        var newPos = this.getEventPosition(event);\n        var ceilLimit, floorLimit, floorHandleElement, ceilHandleElement;\n        if (this.viewOptions.rightToLeft) {\n            ceilLimit = this.dragging.lowLimit;\n            floorLimit = this.dragging.highLimit;\n            floorHandleElement = this.maxHandleElement;\n            ceilHandleElement = this.minHandleElement;\n        }\n        else {\n            ceilLimit = this.dragging.highLimit;\n            floorLimit = this.dragging.lowLimit;\n            floorHandleElement = this.minHandleElement;\n            ceilHandleElement = this.maxHandleElement;\n        }\n        var isUnderFloorLimit = (newPos <= floorLimit);\n        var isOverCeilLimit = (newPos >= this.maxHandlePosition - ceilLimit);\n        var newMinValue;\n        var newMaxValue;\n        if (isUnderFloorLimit) {\n            if (floorHandleElement.position === 0) {\n                return;\n            }\n            newMinValue = this.getMinValue(newPos, true, false);\n            newMaxValue = this.getMaxValue(newPos, true, false);\n        }\n        else if (isOverCeilLimit) {\n            if (ceilHandleElement.position === this.maxHandlePosition) {\n                return;\n            }\n            newMaxValue = this.getMaxValue(newPos, true, true);\n            newMinValue = this.getMinValue(newPos, true, true);\n        }\n        else {\n            newMinValue = this.getMinValue(newPos, false, false);\n            newMaxValue = this.getMaxValue(newPos, false, false);\n        }\n        this.positionTrackingBar(newMinValue, newMaxValue);\n    };\n    SliderComponent.prototype.positionTrackingBar = function (newMinValue, newMaxValue) {\n        if (!ValueHelper.isNullOrUndefined(this.viewOptions.minLimit) &&\n            newMinValue < this.viewOptions.minLimit) {\n            newMinValue = this.viewOptions.minLimit;\n            newMaxValue = MathHelper.roundToPrecisionLimit(newMinValue + this.dragging.difference, this.viewOptions.precisionLimit);\n        }\n        if (!ValueHelper.isNullOrUndefined(this.viewOptions.maxLimit) &&\n            newMaxValue > this.viewOptions.maxLimit) {\n            newMaxValue = this.viewOptions.maxLimit;\n            newMinValue = MathHelper.roundToPrecisionLimit(newMaxValue - this.dragging.difference, this.viewOptions.precisionLimit);\n        }\n        this.viewLowValue = newMinValue;\n        this.viewHighValue = newMaxValue;\n        this.applyViewChange();\n        this.updateHandles(PointerType.Min, this.valueToPosition(newMinValue));\n        this.updateHandles(PointerType.Max, this.valueToPosition(newMaxValue));\n    };\n    SliderComponent.prototype.positionTrackingHandle = function (newValue) {\n        newValue = this.applyMinMaxLimit(newValue);\n        if (this.range) {\n            if (this.viewOptions.pushRange) {\n                newValue = this.applyPushRange(newValue);\n            }\n            else {\n                if (this.viewOptions.noSwitching) {\n                    if (this.currentTrackingPointer === PointerType.Min &&\n                        newValue > this.viewHighValue) {\n                        newValue = this.applyMinMaxRange(this.viewHighValue);\n                    }\n                    else if (this.currentTrackingPointer === PointerType.Max &&\n                        newValue < this.viewLowValue) {\n                        newValue = this.applyMinMaxRange(this.viewLowValue);\n                    }\n                }\n                newValue = this.applyMinMaxRange(newValue);\n                if (this.currentTrackingPointer === PointerType.Min && newValue > this.viewHighValue) {\n                    this.viewLowValue = this.viewHighValue;\n                    this.applyViewChange();\n                    this.updateHandles(PointerType.Min, this.maxHandleElement.position);\n                    this.updateAriaAttributes();\n                    this.currentTrackingPointer = PointerType.Max;\n                    this.minHandleElement.active = false;\n                    this.maxHandleElement.active = true;\n                    if (this.viewOptions.keyboardSupport) {\n                        this.maxHandleElement.focus();\n                    }\n                }\n                else if (this.currentTrackingPointer === PointerType.Max &&\n                    newValue < this.viewLowValue) {\n                    this.viewHighValue = this.viewLowValue;\n                    this.applyViewChange();\n                    this.updateHandles(PointerType.Max, this.minHandleElement.position);\n                    this.updateAriaAttributes();\n                    this.currentTrackingPointer = PointerType.Min;\n                    this.maxHandleElement.active = false;\n                    this.minHandleElement.active = true;\n                    if (this.viewOptions.keyboardSupport) {\n                        this.minHandleElement.focus();\n                    }\n                }\n            }\n        }\n        if (this.getCurrentTrackingValue() !== newValue) {\n            if (this.currentTrackingPointer === PointerType.Min) {\n                this.viewLowValue = newValue;\n                this.applyViewChange();\n            }\n            else if (this.currentTrackingPointer === PointerType.Max) {\n                this.viewHighValue = newValue;\n                this.applyViewChange();\n            }\n            this.updateHandles(this.currentTrackingPointer, this.valueToPosition(newValue));\n            this.updateAriaAttributes();\n        }\n    };\n    SliderComponent.prototype.applyMinMaxLimit = function (newValue) {\n        if (!ValueHelper.isNullOrUndefined(this.viewOptions.minLimit) && newValue < this.viewOptions.minLimit) {\n            return this.viewOptions.minLimit;\n        }\n        if (!ValueHelper.isNullOrUndefined(this.viewOptions.maxLimit) && newValue > this.viewOptions.maxLimit) {\n            return this.viewOptions.maxLimit;\n        }\n        return newValue;\n    };\n    SliderComponent.prototype.applyMinMaxRange = function (newValue) {\n        var oppositeValue = (this.currentTrackingPointer === PointerType.Min)\n            ? this.viewHighValue\n            : this.viewLowValue;\n        var difference = Math.abs(newValue - oppositeValue);\n        if (!ValueHelper.isNullOrUndefined(this.viewOptions.minRange)) {\n            if (difference < this.viewOptions.minRange) {\n                if (this.currentTrackingPointer === PointerType.Min) {\n                    return MathHelper.roundToPrecisionLimit(this.viewHighValue - this.viewOptions.minRange, this.viewOptions.precisionLimit);\n                }\n                else if (this.currentTrackingPointer === PointerType.Max) {\n                    return MathHelper.roundToPrecisionLimit(this.viewLowValue + this.viewOptions.minRange, this.viewOptions.precisionLimit);\n                }\n            }\n        }\n        if (!ValueHelper.isNullOrUndefined(this.viewOptions.maxRange)) {\n            if (difference > this.viewOptions.maxRange) {\n                if (this.currentTrackingPointer === PointerType.Min) {\n                    return MathHelper.roundToPrecisionLimit(this.viewHighValue - this.viewOptions.maxRange, this.viewOptions.precisionLimit);\n                }\n                else if (this.currentTrackingPointer === PointerType.Max) {\n                    return MathHelper.roundToPrecisionLimit(this.viewLowValue + this.viewOptions.maxRange, this.viewOptions.precisionLimit);\n                }\n            }\n        }\n        return newValue;\n    };\n    SliderComponent.prototype.applyPushRange = function (newValue) {\n        var difference = (this.currentTrackingPointer === PointerType.Min)\n            ? this.viewHighValue - newValue\n            : newValue - this.viewLowValue;\n        var minRange = (!ValueHelper.isNullOrUndefined(this.viewOptions.minRange))\n            ? this.viewOptions.minRange\n            : this.viewOptions.step;\n        var maxRange = this.viewOptions.maxRange;\n        if (difference < minRange) {\n            if (this.currentTrackingPointer === PointerType.Min) {\n                this.viewHighValue = MathHelper.roundToPrecisionLimit(Math.min(newValue + minRange, this.viewOptions.ceil), this.viewOptions.precisionLimit);\n                newValue = MathHelper.roundToPrecisionLimit(this.viewHighValue - minRange, this.viewOptions.precisionLimit);\n                this.applyViewChange();\n                this.updateHandles(PointerType.Max, this.valueToPosition(this.viewHighValue));\n            }\n            else if (this.currentTrackingPointer === PointerType.Max) {\n                this.viewLowValue = MathHelper.roundToPrecisionLimit(Math.max(newValue - minRange, this.viewOptions.floor), this.viewOptions.precisionLimit);\n                newValue = MathHelper.roundToPrecisionLimit(this.viewLowValue + minRange, this.viewOptions.precisionLimit);\n                this.applyViewChange();\n                this.updateHandles(PointerType.Min, this.valueToPosition(this.viewLowValue));\n            }\n            this.updateAriaAttributes();\n        }\n        else if (!ValueHelper.isNullOrUndefined(maxRange) && difference > maxRange) {\n            if (this.currentTrackingPointer === PointerType.Min) {\n                this.viewHighValue = MathHelper.roundToPrecisionLimit(newValue + maxRange, this.viewOptions.precisionLimit);\n                this.applyViewChange();\n                this.updateHandles(PointerType.Max, this.valueToPosition(this.viewHighValue));\n            }\n            else if (this.currentTrackingPointer === PointerType.Max) {\n                this.viewLowValue = MathHelper.roundToPrecisionLimit(newValue - maxRange, this.viewOptions.precisionLimit);\n                this.applyViewChange();\n                this.updateHandles(PointerType.Min, this.valueToPosition(this.viewLowValue));\n            }\n            this.updateAriaAttributes();\n        }\n        return newValue;\n    };\n    SliderComponent.prototype.getChangeContext = function () {\n        var changeContext = new ChangeContext();\n        changeContext.pointerType = this.currentTrackingPointer;\n        changeContext.value = +this.value;\n        if (this.range) {\n            changeContext.highValue = +this.highValue;\n        }\n        return changeContext;\n    };\n    return SliderComponent;\n}());\nvar TooltipWrapperComponent = /** @class */ /*@__PURE__*/ (function () {\n    function TooltipWrapperComponent() {\n    }\n    return TooltipWrapperComponent;\n}());\nvar Ng5SliderModule = /** @class */ /*@__PURE__*/ (function () {\n    function Ng5SliderModule() {\n    }\n    return Ng5SliderModule;\n}());\nexport { Ng5SliderModule, ChangeContext, PointerType, LabelType, Options, SliderElementDirective as b, SliderHandleDirective as c, SliderLabelDirective as d, SliderComponent as a, TooltipWrapperComponent as e };\n//# sourceMappingURL=ng5-slider.js.map\n",null]}